---
文章分类:
  - 编程语言与技术
文章标签:
  - 理论
  - Java
文章简介: 
文章精选:
  - 否
是否发布:
  - 否
发布时间: 
创建时间: 
修改时间:
---

### 1. JDK 版本迭代

JDK各版本迭代的发行周期和调整点：

| 发行版本    | 发行时间       | 备注                                        |
| ------- | ---------- | ----------------------------------------- |
| JDK1.0  | 1996.01.23 | Sun 公司发布了Java的第一个开发工具包                    |
| JDK5.0  | 2004.09.30 | 版本号从1.4直接跟新到5.0；平台更名为JavaSE、JavaEE、JavaME |
| JDK8.0  | 2014.03.18 | 继5.0以来变化最大的版本，是长期支持版本（LTS）                |
| JDK9.0  | 2017.09.22 | 此版本开始，每半年更新一次                             |
| JDK10.0 | 2018.03.21 |                                           |
| JDK11.0 | 2018.09.25 | JDK安装包取消独立JRE安装包，是长期支持版本（LTS）             |
| JDK12.0 | 2019.03.19 |                                           |
| ...     | ...        |                                           |
| JDK17.0 | 2021.09    | 发布JDK17.0，版本号也称为21.9，是长期支持版本（LTS）         |
| ...     | ...        |                                           |
| JDK21.0 | 2023.09    | 发布JDK21.0，版本号也成为23.09，是长期支持版本（LTS）        |

JDK各版本都会包含许多的变更，包括语言变更和JVM变更，这两者都会对IDE、字节码库和框架产生重大的影响，此外，不仅会更加其他的API，还会对过时的API进行删除（JDK8之前只是提示）。

相关的名词：

1. Oracle JDK和Open JDK，两个JDK许可证不同。
2. JEP（JDK Enhancement Proposals）：JDK改提案，新想法可以提出非正式的规范，被正式认可的JEP正式写进JDK的发展路线并分配版本号。
3. LTS（Long-term Support）：长期支持版本。

新特性：

- 新的语法规则：自动装箱、自动拆箱、注解、enum、Lambda表达式、方法引用、switch表达式、try-catch变化，record等。
- 增加、过时、删除API：StringBuilder、ArrayList、新的日期时间的API、Optional等。
- 底层的优化、JVM参数调整、GC的变化、内存结构（方法：永久代 --> 元空间） 。

### 2. JDK8新特性

**JDK8中的新特性**：

1. 函数式接口
2. Lambda表达式
3. 方法引用/构造器引用
4. Stream API：并行流、串行流
5. 接口的增强：静态方法、默认方法
6. Optional类
7. 新的时间和日期API
8. 其他新特性：
	- 重复注解
	- 类型注解
	- 通用目标类型判断
	- JDK的更新：集合的流式操作、并发、Arrays、Number和Math、IO/NIO的改进、Reflection获取形参名、String join()、Files
	- 新增工具：jjs、jdeps
	- JVM中Metascape取代PerimGen空间

**JDK8的优势**：

1. 速度更快
2. 代码更少，增加了新的语法：lambda表达式
3. 强大的Stream API：并行流
4. 最大化减少空指针异常：Optional
5. Nashorm引擎，允许JVM上运行JS引用。JS运行命令：`jjs js文件名`。

### 3. JDK8新特性：Lambda表达式

Lambda是一个匿名函数，可以理解为一段可以传递的代码，将代码像数据一样进行传递。使用会更加简洁、更灵活的代码。是一种更紧凑的代码风格。

```java
// 举例1
public static void main(String[] args) {  
	Runnable r1 = new Runnable() {  
		@Override  
		public void run() {  
			System.out.println("Hello World");  
		}  
	};  
	r1.run();  
	System.out.println("----------------------------");
	// 使用Lambda表达式  
	Runnable r2 = () -> {  
		System.out.println("Hello World");  
	};  
	r2.run();  
}  

// 举例2
public static void main(String[] args) {  
	Comparator<Integer> com1 = new Comparator<Integer>() {  
		@Override  
		public int compare(Integer o1, Integer o2) {  
			return Integer.compare(o1, o2);  
		}  
	};  
	System.out.println(com1.compare(1, 2));  
	System.out.println("----------------------------");  
	// 使用Lambda表达式  
	// Comparator<Integer> com2 = (Integer o1, Integer o2) -> Integer.compare(o1, o2);  
	Comparator<Integer> com2 = (o1, o2) -> Integer.compare(o1, o2);  
	System.out.println(com2.compare(1, 2));  
	System.out.println("----------------------------");  
	// 使用方法引用  
	Comparator<Integer> com3 = Integer::compare;  
	System.out.println(com3.compare(1, 2));  
}
```

Lambda格式：`lambda形参列表 -> {lambda方法体};`

- `->` ：lambda操作符或箭头操作符。
- `->` 的左边：lambda形参列表，对应着要重写的接口中的抽象方法的形参列表。
- `->` 的右边：lambda方法体，对应着要接口实现类要重写的方法体。

```java
// 语法格式一：无参，无返回值  
public static void main(String[] args) {  
    Runnable r1 = new Runnable() {  
        @Override  
        public void run() {  
            System.out.println("hello world");  
        }  
    };  
    r1.run();  
    System.out.println("----------------------------");  
    Runnable r2 = () -> {  
        System.out.println("hello world");  
    };  
    r2.run();  
}

// 语法格式二：Lambda 一个参数，但是没有返回值  
public static void main(String[] args) {  
    Consumer<String> con = new Consumer<String>() {  
        @Override  
        public void accept(String s) {  
            System.out.println(s);  
        }  
    };  
    con.accept("hello world");  
    System.out.println("----------------------------");  
    Consumer<String> con1 = (String s) -> {  
        System.out.println(s);  
    };  
    con1.accept("hello world");  
}

// 语法格式三：数据类型可以省略，由编译器推断，称为类型推断  
public static void main(String[] args) {  
    Consumer<String> con = new Consumer<String>() {  
        @Override  
        public void accept(String s) {  
            System.out.println(s);  
        }  
    };  
    con.accept("hello world");  
    System.out.println("----------------------------");  
    Consumer<String> con1 = (s) -> {  
        System.out.println(s);  
    };  
    con1.accept("hello world");  
}

public static void main(String[] args) {  
    int[] arr = {1, 2, 3}; // 类型推断  
    HashMap<String, String> map = new HashMap<>(); // 类型推断  
    var entrySet = map.entrySet(); // 类型推断，在JDK10版本以上  
}

// 语法格式四：Lambda，只有一个参数时，参数的括号可以省略  
public static void main(String[] args) {  
    Consumer<String> con = (s) -> {  
        System.out.println(s);  
    };  
    con.accept("hello world");  
    System.out.println("----------------------------");  
    Consumer<String> con1 = s -> {  
        System.out.println(s);  
    };  
    con1.accept("hello world");  
}

// 语法格式五：Lambda 需要两个以上的参数，多条执行语句，可以有返回值  
public static void main(String[] args) {  
    Comparator<Integer> com1 = new Comparator<Integer>() {  
        @Override  
        public int compare(Integer o1, Integer o2) {  
            System.out.println("o1：" + o1);  
            System.out.println("o2：" + o2);  
            return Integer.compare(o1, o2);  
        }  
    };  
    System.out.println(com1.compare(1, 2));
    System.out.println("----------------------------");  
    Comparator<Integer> com2 = (o1, o2) -> {  
        System.out.println("o1：" + o1);  
        System.out.println("o2：" + o2);  
        return Integer.compare(o1, o2);  
    };  
    System.out.println(com2.compare(1, 2)); 
}

// 语法格式六：当lambda只有一条语句时，return与大括号若有，都可以省略  
public static void main(String[] args) {  
    Comparator<Integer> com1 = (o1, o2) -> {  
        return Integer.compare(o1, o2);  
    };  
    System.out.println(com1.compare(1, 2));  
    System.out.println("----------------------------");  
    Comparator<Integer> com2 = (o1, o2) -> Integer.compare(o1, o2);  
    System.out.println(com2.compare(1, 2));  
    System.out.println("----------------------------");  
    Comparator<Integer> com3 = Integer::compare; // 使用方法引用 
    System.out.println(com3.compare(1, 2));  
}
```

Lambda表达式的本质：

- lambda表达式作为接口的实现类的对象。
- lambda表达式是一个匿名函数。

JDK8再引入Lambda表达式之后，Java也开始支持函数式编程。Lambda表达式不是Java最早使用的。目前C++、C#、Python、Scala等均支持Lambda表达式。

- 面向对象的思想：做一件事，是需要先找到解决这个事的对象，调用其对应的方法，完成此事。
- 函数式编程思想：只要能获取结果，谁去做的，怎么做都不重要，重视结果，不重视过程。

**函数式接口**：接口中只声明了一个抽象方法。当给函数式接口提供实现类的对象时，就可以使用lambda表达式。

函数式接口显示校验注解（JDK8）：`@FunctionalInterface`。

函数式接口所在的包：`java.lang.function`。

自定义函数式接口示例：

```java
@FunctionalInterface  
public interface MyFunctionInterface {  
    void method();  
}

public static void main(String[] args) {  
    MyFunctionInterface mfi = () -> {  
        System.out.println("Hello Lambda");  
    };  
    mfi.method();  
}
```

**函数式接口核心（四个）**：

| 函数式接口            | 名称    | 参数类型 | 用途                                                      |
| ---------------- | ----- | ---- | ------------------------------------------------------- |
| `Consumer<T>`    | 消费型接口 | T    | 对类型为T的对象应用操作。<br>方法：`void accept(T t)`                  |
| `Supplier<T>`    | 供给型接口 | 无    | 返回类型为T的对象。<br>方法：`T get()`                              |
| `Function<T, R>` | 函数型接口 | T, R | 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。<br>方法：`R apply(T t)`      |
| `Predicate<T>`   | 判断型接口 | T    | 确定类型为T的对象是否满足某约束，并返回boolean值。<br>方法：`boolean test(T t)` |

基于函数式接口核心扩展或延伸的其它接口：

消费类型接口：`Consumer<T>`，有形参，但是返回值类型是void。

| 接口名                   | 抽象方法                             | 描述               |
| --------------------- | -------------------------------- | ---------------- |
| **`BiConsumer<T,U>`** | `void accept(T t, U u)`          | 接收两个对象用于完成功能。    |
| `DoubleConsumer`      | `void accept(double value)`      | 接收一个double值      |
| `IntConsumer`         | `void accept(int value)`         | 接收一个int值         |
| `LongConsumer`        | `void accept(long value)`        | 接收一个long值        |
| `ObjDoubleConsumer`   | `void accept(T t, double value)` | 接收一个对象和一个double值 |
| `ObjIntConsumer`      | `void accept(T t, int value)`    | 接收一个对象和一个int值    |
| `ObjLongConsumer`     | `void accept(T t, long value)`   | 接收一个对象和一个long值   |

供给型接口：`Supplier<T>`，无参，但是有返回值。

| 接口名               | 抽象方法                     | 描述           |
| ----------------- | ------------------------ | ------------ |
| `BooleanSupplier` | `boolean getAsBoolean()` | 返回一个boolean值 |
| `DoubleSupplier`  | `double getAsDouble()`   | 返回一个double值  |
| `IntSupplier`     | `int getAsInt()`         | 返回一个Int值     |
| `LongSupplier`    | `long getAsLong()`       | 返回一个long值    |

函数型接口：`Function<T, R>`，既有参数又有返回值。

| 接口名                       | 抽象方法                                              | 描述                          |
| ------------------------- | ------------------------------------------------- | --------------------------- |
| **`UnaryOperator<T>`**    | `T apply(T t)`                                    | 接收一个T类型对象，返回一个T类型对象结果       |
| `DoubleFunction<R>`       | `R apply(double value)`                           | 接收一个double值，返回一个R类型对象       |
| `IntFunction<R>`          | `R apply(int value)`                              | 接收一个int值，返回一个R类型对象          |
| `LongFunction<R>`         | `R apply(long value)`                             | 接收一个long值，返回一个R类型对象         |
| `ToDoubleFunction<T>`     | `double apply(T t)`                               | 接收一个T类型对象，返回一个double        |
| `ToIntFunction<T>`        | `int apply(T t)`                                  | 接收一个T类型对象，返回一个int           |
| `ToLongeFunction<T>`      | `long apply(T t)`                                 | 接收一个T类型对象，返回一个long          |
| `DoubleToIntFunction`     | `int apply(double value)`                         | 接收一个double值，返回一个int结果       |
| `DoubleToLongFunction`    | `long apply(double value)`                        | 接收一个double值，返回一个long结果      |
| `IntToDoubleFunction`     | `double apply(int value)`                         | 接收一个int值，返回一个double结果       |
| `IntToLongFunction`       | `long apply(int value)`                           | 接收一个int值，返回一个long结果         |
| `LongToDoubleFunction`    | `double apply(long value)`                        | 接收一个long值，返回一个double结果      |
| `LongToIntFunction`       | `int apply(long value)`                           | 接收一个long值，返回一个int结果         |
| `DoubleUnaryOperator`     | `double appplyAsInt(double operand)`              | 接收一个double值，返回一个double结果    |
| `IntUnaryOperator`        | `int appplyAsInt(int operand)`                    | 接收一个Int值，返回一个int结果          |
| `LongUnaryOperator`       | `long appplyAsInt(long operand)`                  | 接收一个long值，返回一个long结果        |
| **`BiFunction<T, U, R>`** | `R apply(T t, U u)`                               | 接收一个T类型和一个U类型对象，返回一个R类型对象结果 |
| **`BinaryOperator<T>`**   | `T apply(T t, T u)`                               | 接两个T类型对象，返回一个T类型对象结果        |
| `ToDoubleBiFunction<T>`   | `double applyAsDouble(T t, U u)`                  | 接收一个T类型和一个U类型对象，返回一个double  |
| `ToIntBiFunction<T>`      | `int applyAsInt(T t, U u)`                        | 接收一个T类型和一个U类型对象，返回一个int     |
| `ToLongeBiFunction<T>`    | `long applyAsLong(T t, U u)`                      | 接收一个T类型和一个U类型对象，返回一个long    |
| `DoubleBinaryOperator`    | `double applyAsDouble(double left, double right)` | 接收两个double值，返回一个double结果    |
| `IntBinaryOperator`       | `int applyAsInt(int left, int right)`             | 接收两个int值，返回一个int结果          |
| `LongBinaryOperator`      | `long applyAsLong(long left, long right)`         | 接收两个long值，返回一个long结果        |

判断型接口：`Predicate<T>`，有参，但是返回值类型是boolean。

| 接口名                    | 抽象方法                         | 描述          |
| ---------------------- | ---------------------------- | ----------- |
| **`BiPredicate<T,U>`** | `boolean test(T t, U u)`     | 接收两个对象。     |
| `DoublePredicate`      | `boolean test(double value)` | 接收一个double值 |
| `InPredicate`          | `boolean test(int value)`    | 接收一个int值    |
| `LongPredicate`        | `boolean test(long value)`   | 接收一个long值   |

**Lambda表达式的语法规则总结**：

- `->` 的左边：lambda形参列表，参数类型可以省略。如果形参只有一个，则一对 `()` 也可以省略。
- `->` 的右边：lambda方法体，重写的方法的方法体，如果方法体中只有一行执行语句，则一对 `{}` 可以省略，如果一行执行语句有return关键字，也必须一并省略。

### 4. JDK8新特性：方法引用与构造器引用

**方法引用**：是基于lambda表达式的进一步简写；一个函数式接口的实例时，可以使用lambda表达式提供此示例，而再满足一定条件的情况下，还可以使用方法引用或构造器来用替换lambda表达式。

方法引用的本质：作为函数式接口的实例。

方法引用的格式：`类(或对象) :: 方法名`。

```java
// 语法格式六：当lambda只有一条语句时，return与大括号若有，都可以省略  
public static void main(String[] args) {  
    Comparator<Integer> com1 = (o1, o2) -> {  
        return Integer.compare(o1, o2);  
    };  
    System.out.println(com1.compare(1, 2));  
    System.out.println("----------------------------");  
    Comparator<Integer> com2 = (o1, o2) -> Integer.compare(o1, o2);  
    System.out.println(com2.compare(1, 2));  
    System.out.println("----------------------------");  
    Comparator<Integer> com3 = Integer::compare; // 使用方法引用 
    System.out.println(com3.compare(1, 2));  
}
```

方法引用使用的情况（三种）：

```java
// 辅助类
public class Person {  
    String code;  
    String name;  
    int age;  
  
    public Person() {  
    }  
  
    public Person(String code, String name, int age) {  
        this.code = code;  
        this.name = name;  
        this.age = age;  
    }  
  
    public Person(String code) {  
        this.code = code;  
    }  
  
    public Person(String code, String name) {  
        this.code = code;  
        this.name = name;  
    }  
  
    public String getCode() {  
        return code;  
    }  
  
    public void setCode(String code) {  
        this.code = code;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
    
	@Override  
	public boolean equals(Object o) {  
	    if (this == o) return true;  
	    if (o == null || getClass() != o.getClass()) return false;  
	    Person person = (Person) o;  
	    return age == person.age && Objects.equals(code, person.code) && Objects.equals(name, person.name);  
	}  
	  
	@Override  
	public int hashCode() {  
	    return Objects.hash(code, name, age);  
	}
	
    @Override  
    public String toString() {  
        return "Person{" +  
                "code='" + code + '\'' +  
                ", name='" + name + '\'' +  
                ", age='" + age + '\'' +  
                '}';  
    }  
}
```

情况1：`对象 :: 实例方法`

使用的要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值相同（或一致），此时可以考虑使用方法b实现对方法a的替换、覆盖。方法b是非静态的方法，需要用对象调用。

```java
import java.io.PrintStream;  
import java.util.function.Consumer;

public static void test1() {  
    Consumer<String> con1 = new Consumer<String>() {  
        @Override  
        public void accept(String s) {  
            System.out.println(s);  
        }  
    };  
    con1.accept("Hello World");  
    System.out.println("----------------------------");  
    Consumer<String> con2 = s -> System.out.println(s);  
    con2.accept("Hello Lambda");  
    System.out.println("----------------------------");  
    PrintStream ps = System.out;  
    Consumer<String> con3 = ps::println;  
    con3.accept("Hello Method Reference");  
}

// ----
import java.util.function.Supplier;

public static void test2() {  
    Person person = new Person("001", "张三", 20);  
    Supplier<String> sup1 = new Supplier<>() {  
        @Override  
        public String get() {  
            return person.getName();  
        }  
    };  
    System.out.println(sup1.get());  
    System.out.println("----------------------------");  
    Supplier<String> sup2 = () -> person.getName();  
    System.out.println(sup2.get());  
    System.out.println("----------------------------");  
    Supplier<String> sup3 = person::getName;  
    System.out.println(sup3.get());  
}
```

情况2：`类 :: 静态方法`

使用的要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个静态方法b的形参列表和返回值相同（或一致），此时可以考虑使用方法b实现对方法a的替换、覆盖。方法b是静态的方法，需要用类调用。

```java
import java.util.Comparator;

public static void test3() {  
    Comparator<Integer> com1 = new Comparator<>() {  
        @Override  
        public int compare(Integer o1, Integer o2) {  
            return Integer.compare(o1, o2);  
        }  
    };  
    System.out.println(com1.compare(12, 13));  
    System.out.println("----------------------------");  
    Comparator<Integer> com2 = (o1, o2) -> Integer.compare(o1, o2);  
    System.out.println(com2.compare(12, 13));  
    System.out.println("----------------------------");  
    Comparator<Integer> com3 = Integer::compare;  
    System.out.println(com3.compare(12, 13));  
}

// ---
import java.util.function.Function;

public static void test4() {  
    Function<Double, Long> fun1 = new Function<>() {  
        @Override  
        public Long apply(Double aDouble) {  
            return Math.round(aDouble);  
        }  
    };  
    System.out.println(fun1.apply(12.3));  
    System.out.println("----------------------------");  
    Function<Double, Long> fun2 = aDouble -> Math.round(aDouble);  
    System.out.println(fun2.apply(12.3));  
    System.out.println("----------------------------");  
    Function<Double, Long> fun3 = Math::round;  
    System.out.println(fun3.apply(12.3));  
}
```

情况3：`类 :: 实例方法`

使用的要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的返回值相同（或一致），同时抽象方法a中有n个参数，方法b中有n-1ge参数，并且抽象方法a的第一个参数作为方法b的调用者，抽象方法a的后n-1个参数与方法b的参数类型相同（或一致）。此时可以考虑使用方法b实现对方法a的替换、覆盖。方法b是非静态的方法，需要用对象调用，形式b方法所属的类::b方法名。

```java
import java.util.Comparator;  

public static void test5() {  
    Comparator<String> com1 = new Comparator<String>() {  
        @Override  
        public int compare(String s1, String s2) {  
            return s1.compareTo(s2);  
        }  
    };  
    System.out.println(com1.compare("abc", "abd"));  
    System.out.println("----------------------------");  
    Comparator<String> com2 = (s1, s2) -> s1.compareTo(s2);  
    System.out.println(com2.compare("abc", "abd"));  
    System.out.println("----------------------------");  
    Comparator<String> com3 = String::compareTo;  
    System.out.println(com3.compare("abc", "abd"));  
}

// ---
import java.util.function.BiPredicate;  

public static void test6() {  
    BiPredicate<String, String> biPre1 = new BiPredicate<String, String>() {  
        @Override  
        public boolean test(String s1, String s2) {  
            return s1.equals(s2);  
        }  
    };  
    System.out.println(biPre1.test("abc", "abc"));  
    System.out.println("----------------------------");  
    BiPredicate<String, String> biPre2 = (s1, s2) -> s1.equals(s2);  
    System.out.println(biPre2.test("abc", "abc"));  
    System.out.println("----------------------------");  
    BiPredicate<String, String> biPre3 = String::equals;  
    System.out.println(biPre3.test("abc", "abc"));  
}

// ---
import java.util.function.Function;

public static void test7() {  
    Person person = new Person("001", "张三", 20);  
    Function<Person, String> fun1 =new Function<Person, String>() {  
        @Override  
        public String apply(Person person) {  
            return person.getName();  
        }  
    };  
    System.out.println(fun1.apply(person));  
    System.out.println("----------------------------");  
    Function<Person, String> fun2 = p -> p.getName();  
    System.out.println(fun2.apply(person));  
    System.out.println("----------------------------");  
    Function<Person, String> fun3 = Person::getName;  
    System.out.println(fun3.apply(person));  
}
```

**构造器引用**：调用了类名对应的类中的某个确定的构造器。具体调用那个构造器，取决于函数式结构的抽象方法的形参列表。

方法引用的格式：`类 :: new`。

```java
import java.util.function.Supplier;

public static void test8() {  
    Supplier<Person> sup1 = new Supplier<Person>() {  
        @Override  
        public Person get() {  
            return new Person();  
        }  
    };  
    System.out.println(sup1.get());  
    System.out.println("----------------------------");  
    Supplier<Person> sup2 = () -> new Person();  
    System.out.println(sup2.get());  
    System.out.println("----------------------------");  
    Supplier<Person> sup3 = Person::new;  
    System.out.println(sup3.get());  
}

// ---
import java.util.function.Function;

public static void test9() {  
    Function<String, Person> fun1 = new Function<String, Person>() {  
  
        @Override  
        public Person apply(String s) {  
            return new Person(s);  
        }  
    };  
    System.out.println(fun1.apply("001"));  
    System.out.println("----------------------------");  
    Function<String, Person> fun2 = s -> new Person(s);  
    System.out.println(fun2.apply("002"));  
    System.out.println("----------------------------");  
    Function<String, Person> fun3 = Person::new;  
    System.out.println(fun3.apply("003"));  
}

// ---
import java.util.function.BiFunction;

public static void test10() {  
    BiFunction<String, String, Person> biFun1 = new BiFunction<String, String, Person>() {  
        @Override  
        public Person apply(String code, String name) {  
            return new Person(code, name);  
        }  
    };  
    System.out.println(biFun1.apply("001", "张三"));  
    System.out.println("----------------------------");  
    BiFunction<String, String, Person> biFun2 = (code, name) -> new Person(code, name);  
    System.out.println(biFun2.apply("002", "李四"));  
    System.out.println("----------------------------");  
    BiFunction<String, String, Person> biFun3 = Person::new;  
    System.out.println(biFun3.apply("003", "王五"));  
}
```

**数组引用**：

数组引用格式：`数组名[] :: new`。

```java
import java.util.function.Function;

public static void test11() {  
    Function<Integer, Person[]> fun1 = new Function<Integer, Person[]>() {  
        @Override  
        public Person[] apply(Integer num) {  
            return new Person[num];  
        }  
    };  
    System.out.println(fun1.apply(10).length);  
    System.out.println("----------------------------");  
    Function<Integer, Person[]> fun2 = num -> new Person[num];  
    System.out.println(fun2.apply(10).length);  
    System.out.println("----------------------------");  
    Function<Integer, Person[]> fun3 = Person[]::new;  
    System.out.println(fun3.apply(10).length);  
}
```

### 5. JDK8新特性：Stream流的API

Stream API：`java.util.stream`，真正的把函数式编程风格引入到了Java中，是对Java类库最好的补充。关注是对多个数据的计算（排序、查找、过滤、映射、遍历等）。

Stream：是JDK8中集中处理集合的关键抽象概念。使用Stream API对集合数据进行操作，就类似于使用SQL执行的数据库查询。是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。

Stream和Collection集合的区别：Collection是一种静态内存数据结构，讲的是数据；而Stream是有关计算的，讲的是计算。前者主要是面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算。

**Stream使用的注意点**：

1. Stream本身不会存储元素。
2. Stream不会改变源对象。它们会返回一个持有结果的新Stream。
3. Stream操作是延迟执行的。等到需要结果的时候才执行，一旦执行终止操作，就执行中间操作链，并产生结果。
4. Steam一旦执行了终止操作，就不能再调用它中间操作或终止操作了。

**Stream执行流程**：1. Stream实例化；2. 一系列的中间操作；3. 执行终止操作。

Stream实例化：一个数据源通过集合、数组、Stream的 `of()` 方法获取一个流。

```java
import java.util.Arrays;  
import java.util.List;  
import java.util.stream.IntStream;  
import java.util.stream.Stream;  
  
public class MainTest1 {  
  
    public static void main(String[] args) {  
        test1();  
        test2();  
        test3();  
    }  
  
    // 创建方式1：通过集合  
    public static void test1() {  
        List<Person> list = getPersonList();  
        // 返回一个顺序流：default Stream<E> stream() 默认方法  
        Stream<Person> stream = list.stream();  
  
        // 返回一个并行流：default Stream<E> parallelStream() 默认方法  
        Stream<Person> stream1 = list.parallelStream();  
    }  
  
    // 创建方式2：通过数组  
    public static void test2() {  
        Integer[] array = new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  
        // 通过调用Arrays类的 static <T> Stream<T> stream(T[] array) 方法返回一个流  
        Stream<Integer> stream = Arrays.stream(array);  
  
        int[] array1 = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  
        IntStream stream1 = Arrays.stream(array1);  
    }  
  
    // 创建方式3：通过Stream的of方法  
    public static void test3() {  
        // 在数据既不是集合也不是数组的情况下，使用Stream.of方法的方法创建  
        Stream<String> stream = Stream.of("张三", "李四", "王五", "赵六");  
    }  
  
	public static List<Person> getPersonList() {  
	    List<Person> list = new ArrayList<>();  
	    list.add(new Person("001", "张三", 20));  
	    list.add(new Person("002", "李四", 30));  
	    list.add(new Person("003", "王五", 40));  
	    list.add(new Person("004", "赵六", 50));  
	    list.add(new Person("005", "钱七", 60));  
	    return list;  
	}
}
```

一系列的中间操作：每次处理都会返回一个持有结果的新的Stream，即中间操作的方法返回值依旧是Stream类型的对象，可视作为链式操作，但没有终止操作前，此中间操作不会真正执行。也称为“惰性求值”。

中间操作：筛选与切片

| 方法                    | 描述                                                        |
| --------------------- | --------------------------------------------------------- |
| `filter(Predicate p)` | 接收Lambda，从流中排出某些元素。                                       |
| `distinct()`          | 筛选，通过流所生成元素的 `hashCode()` 和 `equals()` 去除重复元素。            |
| `limit(long maxSize)` | 截断流，使其元素不超过给定数量。                                          |
| `skip(long n)`        | 跳过元素，返回一个跳过前n个元素的流。<br>若流中元素不足n个，则返回一个空流，与 `limit(n)` 互补。 |

中间操作：映射

| 方法                                | 描述                                            |
| --------------------------------- | --------------------------------------------- |
| `map(Function f)`                 | 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。        |
| `mapToDouble(toDoubleFunction f)` | 接收一个函数作为参数，该函数会被应用到每个元素上，并产生一个新的DoubleStream。 |
| `mapToInt(toIntFunction f)`       | 接收一个函数作为参数，该函数会被应用到每个元素上，并产生一个新的IntStream。    |
| `mapToLong(toLongFunction f)`     | 接收一个函数作为参数，该函数会被应用到每个元素上，并产生一个新的LongStream。   |
| `flatMap(Function f)`             | 接收一个函数作为参数，将函数中的每一个值都换成另一个流，然后把所有的流连接成一个流。    |

中间操作：排序

| 方法                       | 描述                 |
| ------------------------ | ------------------ |
| `sorted()`               | 产生一个新流，其中按自然顺序排序。  |
| `sorted(Comparator com)` | 产生一个新流，其中按比较器顺序排序。 |

```java
import java.util.ArrayList;  
import java.util.Arrays;  
import java.util.List;  
import java.util.stream.IntStream;  
import java.util.stream.Stream;  
  
public class MainTest2 {  
  
    public static void main(String[] args) {  
        test1();  
        test2();  
        test3();  
    }  
  
    // 筛选与切片  
    public static void test1() {  
        List<Person> list = getPersonList();  
        // filter(Predicate p)——接收 Lambda，从流中排除某些元素  
        list.stream().filter(person -> person.getAge() > 50).forEach(System.out::println);  
        System.out.println("----------------------------");  
        // limit(long maxSize)——截断流，使其元素不超过给定数量  
        list.stream().limit(3).forEach(System.out::println);  
        System.out.println("----------------------------");  
        // skip(long n)——跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补  
        list.stream().skip(3).forEach(System.out::println);  
        System.out.println("----------------------------");  
        // distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素  
        list.add(new Person("001", "张三", 20));  
        list.forEach(System.out::println);  
        System.out.println("---------去重后----------");  
        list.stream().distinct().forEach(System.out::println);  
    }  
  
    // 映射  
    public static void test2() {  
        List<String> list = Arrays.asList("aa", "bb", "cc", "dd", "ee");  
        // map(Function f)——接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素  
        // list.stream().map(str -> str.toUpperCase()).forEach(System.out::println); // lambda 表达式  
        list.stream().map(String::toUpperCase).forEach(System.out::println);  
        System.out.println("----------------------------");  
        // 获取Person年龄大于50的人员的姓名，过滤和映射位置先后都可以  
        List<Person> list2 = getPersonList();  
        list2.stream().filter(person -> person.getAge() > 50).map(Person::getName).forEach(System.out::println);  
    }  
  
    // 排序  
    public static void test3() {  
        Integer[] arr = {10, 1, 7, 5, 4, 3, 6, 2, 8, 9};  
        // sorted()——自然排序  
        Arrays.stream(arr).sorted().forEach(System.out::println);  
        System.out.println("----------------------------");  
        System.out.println("arr的数据：" + Arrays.toString(arr));  
        System.out.println("----------------------------");  
        // sorted(Comparator com)——定制排序  
        Arrays.stream(arr).sorted(Integer::compare).forEach(System.out::println);  
        System.out.println("----------------------------");  
        Arrays.stream(arr).sorted((o1, o2) -> -(o1 - o2)).forEach(System.out::println);  
    }  
  
    public static List<Person> getPersonList() {  
        List<Person> list = new ArrayList<>();  
        list.add(new Person("001", "张三", 20));  
        list.add(new Person("002", "李四", 30));  
        list.add(new Person("003", "王五", 40));  
        list.add(new Person("004", "赵六", 50));  
        list.add(new Person("005", "钱七", 60));  
        return list;  
    }  
}
```

执行终止操作：操作的方法返回的类型不再是Stream了。执行了终止操作，意味着整个Stream操作结束了。一旦执行终止操作，就执行中间操作链，产生最终结果并结束Stream。

终止操作：匹配与查找

| 方法                       | 描述                                                              |
| ------------------------ | --------------------------------------------------------------- |
| `allMatch(Predicate p)`  | 检查是否匹配所有元素。                                                     |
| `anyMatch(Predicate p)`  | 检查是否至少匹配一个元素。                                                   |
| `noneMatch(Predicate p)` | 检查是否没有匹配所有元素。                                                   |
| `findFirst()`            | 返回第一个元素。                                                        |
| `findAny()`              | 返回当前流中的任意元素。                                                    |
| `count()`                | 返回当前流中元素总数。                                                     |
| `max(Comparator c)`      | 返回当前流中最大值。                                                      |
| `mix(Comparator c)`      | 返回当前流中最小值。                                                      |
| `forEach(Comsumer c)`    | 内部迭代使用Collection接口，需要用户做迭代（外部迭代）。<br>Stream API使用内部迭代，做了迭代操作步骤。 |

终止操作：归约

> map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名。

| 方法                                     | 描述                                   |
| -------------------------------------- | ------------------------------------ |
| `reduce(T identity, BinaryOperator b)` | 可以将流中元素反复结合起来，得到一个值，返回T。             |
| `reduce(BinaryOperator b)`             | 可以将流中元素反复结合起来，得到一个值，返回`Optional<T>`。 |

终止操作：收集

| 方法                     | 描述                                                    |
| ---------------------- | ----------------------------------------------------- |
| `collect(Collector c)` | 将流转化为其它形式。接收一个Collection接口的实现。<br>用于给Stream中元素做汇总的方法。 |

> Collector 接口种方法的实现决定了如何对流执行收集的操作（如List、Set、Map）。
> Collectors实用类提供了许多静态方法，可以方便地创建常见收集器实例。

| 方法                  | 返回类型                                    | 作用                                                |
| ------------------- | --------------------------------------- | ------------------------------------------------- |
| `toList`            | `Collector<T, ?, List<T>>`              | 把流中元素收集到List                                      |
| `toSet`             | `Collector<T, ?, Set<T>>`               | 把流中元素收集到Set                                       |
| `toCollection`      | `Collector<T, ?, C>`                    | 把流中元素收集到创建的集合中                                    |
| `counting`          | `Collector<T, ?, Long>`                 | 计算流中元素的个数                                         |
| `summingInt`        | `Collector<T, ?, Integer>`              | 对流中元素的整数属性求和                                      |
| `averagingInt`      | `Collector<T, ?, Double>`               | 对流中元素Integer属性的平均值                                |
| `summarizingInt`    | `Collector<T, ?, IntSummaryStatistics>` | 收集流中Integer属性的统计值，如：平均值                           |
| `joining`           | `Collector<CharSequence, ?, String>`    | 连接流中每个字符串                                         |
| `maxBy`             | `Collector<T, ?, Optional<T>>`          | 根据比较器选择最大值                                        |
| `minBy`             | `Collector<T, ?, Optional<T>>`          | 根据比较器选择最小值                                        |
| `reducing`          | `Collector<T, ?, Optional<T>>`          | 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而规约成单个值 |
| `collectingAndThen` | `Collector<T, A, RR>`                   | 包裹另一个收集器，对其结果转换函数。                                |
| `groupingBy`        | `Collector<T, ?, Map<K,List<T>>>`       | 根据某属性值对流分组，属性为K，结果为V。                             |
| `partitioningBy`    | `Collector<T, ?, Map<Boolean,List<T>>>` | 根据某属性值true或false进行分区                              |

```java
import java.util.*;  
import java.util.stream.Collectors;  
  
public class MainTest {  
    public static void main(String[] args) {  
        test1();  
        test2();  
        test3();  
    }  
  
    // 匹配与查找  
    public static void test1() {  
        List<Person> list = getPersonList();  
        // allMatch(Predicate p)--检查是否匹配所有元素  
        System.out.println(list.stream().allMatch(person -> person.getAge() > 40));  
        System.out.println("----------------------------");  
        // anyMath(Predicate p)--检查是否至少匹配一个元素  
        System.out.println(list.stream().anyMatch(person -> person.getAge() > 40));  
        System.out.println("----------------------------");  
        // findFirst()--返回第一个元素  
        System.out.println(list.stream().findFirst().get());  
        System.out.println("----------------------------");  
        // count()--返回流中元素的总个数  
        System.out.println(list.stream().count());  
        System.out.println("----------------------------");  
        // max(Comparator c)--返回流中最大值，默认就是返回流中最后一个元素  
        // System.out.println(list.stream().max((p1, p2) -> p1.getAge() - p2.getAge()).get());  
        System.out.println(list.stream().max(Comparator.comparingInt(Person::getAge)).get());  
        System.out.println("----------------------------");  
        // min(Comparator c)--返回流中最小值，默认就是返回流中第一个元素  
        // System.out.println(list.stream().min((p1, p2) -> -(p1.getAge() - p2.getAge())).get()); //举例  
        System.out.println(list.stream().min(Comparator.comparingInt(Person::getAge)).get());  
        System.out.println("----------------------------");  
        // forEach(Consumer c)--内部迭代  
        list.stream().forEach(System.out::println);  
        // JDK8中集合增加了一个forEach()方法，遍历方式：1. 使用Iterator；2. 增强for；3. 一般for； 4. forEach()        
        list.forEach(System.out::println);  
    }  
  
    // 规约  
    public static void test2() {  
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  
        // reduce(T identity,BinaryOperator b)--将流中元素反复结合起来，得到一个值。identity：初始值/种子  
        // list.stream().reduce(0, (x1, x2) -> x1 + x2);  
        System.out.println(list.stream().reduce(0, Integer::sum));  
        System.out.println("----------------------------");  
        List<Person> list1 = getPersonList();  
        // reduce(BinaryOperator b)--将流中元素反复结合起来，得到一个值  
        // 获取员工年龄的平均值  
        System.out.println(list1.stream().map(Person::getAge).reduce(Integer::sum).get() / list1.size());  
    }  
  
    // 收集  
    public static void test3() {  
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  
        List<Integer> list1 = list.stream().filter(item -> item > 5).collect(Collectors.toList());  
        list.forEach(System.out::println);  
        System.out.println();  
        list1.forEach(System.out::println);  
        System.out.println("----------------------------");  
        List<Person> list2 = getPersonList();  
        List<Person> list3 = list2.stream().sorted(((o1, o2) -> o2.getAge() - o1.getAge())).collect(Collectors.toList());  
        list3.forEach(System.out::println);  
    }  
  
  
    public static List<Person> getPersonList() {  
        List<Person> list = new ArrayList<>();  
        list.add(new Person("001", "张三", 20));  
        list.add(new Person("002", "李四", 30));  
        list.add(new Person("003", "王五", 40));  
        list.add(new Person("004", "赵六", 50));  
        list.add(new Person("005", "钱七", 60));  
        return list;  
    }  
}
```

JDK9中新增Stream API

- Stream实例化方法：`ofNullable()` 实例化方法。JDK8中不能完全为null，否则会报空指针异常。
- `iterator()` 重载。

```java
// JDK8
Stream.iterate(1, i -> i + 1).limit(10).forEach(System.out::println);  
// JDK9--不一定能运行
Stream.iterate(1, i -> i < 10, i -> i + 1).forEach(System.out::println);
```

### 6. 新语法结构

> 将开发者从复杂、繁琐的低层次抽象中逐渐转向更高层次的抽象，既降低代码量，又避免意外编程错误出现，进而提高代码质量和开发效率。

**Java的REPL工具：jShell命令**

> JDK9新特性

jShell：像Python和Scala之类语言的REPL工具（交互式编程环境，read-evaluate-print-loop）。即写即得、快速运行。

jShell常用指令：

- `/help`：获取有关使用jShell工具的信息。
- `/help intro`：jShell工具的介绍。
- `/list`：列出当前session里所有有效的代码片段。
- `/vars`：查看当前session下所有创建过的变量。
- `/methods`：查看当前session下所有创建过的方法。
- `/imports`：列出导入的包。
- `/history`：键入的内容的历史记录。
- `/edit 方法名`：使用外部代码编辑器来编写Java代码。
- `/open`：从外部文件加载源代码。
- `/exit`：推出jShell工具。

**异常处理：try-catch资源关闭**

> JDK7新特性
> JDK9新特性

```java
import java.io.*;  
  
public class MainTest {  
    public static void main(String[] args) {  
        test1();  
        test2();  
        test3();  
    }  
  
    // JDK7之前的写法  
    public static void test1() {  
        FileWriter fw = null;  
        BufferedWriter bw = null;  
        try {  
            fw = new FileWriter("./test.txt");  
            bw = new BufferedWriter(fw);  
            bw.write("hello world");  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                if (bw != null) {  
                    bw.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
  
    // JDK7的写法 -- 要求 try()中的代码实现Closable接口或者AutoClosable接口  
    public static void test2() {  
        try (FileWriter fw = new FileWriter("./test.txt");  
             BufferedWriter bw = new BufferedWriter(fw);  
        ) {  
            bw.write("hello world");  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
  
    // JDK9 -- 流的声明可以放在try()外定义  
    public static void test3() {  
        InputStreamReader reader = new InputStreamReader(System.in);  
        OutputStreamWriter writer = new OutputStreamWriter(System.out);  
        try (reader; writer) {  
            // 此时的reader和writer是final的，不可以再被赋值  
            // reader=new InputStreamReader(System.in);  
            writer.write("hello world");  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
}
```

**局部变量的类型推断**

> JDK10新特性

```java
import java.util.*;  
  
public class MainTest {  
    public static void main(String[] args) {  
        test1();  
    }  
  
    public static void test1() {  
        // 局部变量的实例化  
        var list = new ArrayList<String>();  
        var set = new LinkedHashSet<>();  
        var map = new HashMap<String, Object>();  
  
        // 增强for循环中的索引  
        for (var v : list) {  
            System.out.println(v);  
        }  
  
        // 传统for循环  
        for (var i = 0; i < list.size(); i++) {  
            System.out.println(list.get(i));  
        }  
  
        // 返回值类型复杂泛型结构  
        // Iterator<Object> iterator = set.iterator();  
        var iterator = set.iterator();  
        //Set<Map.Entry<String, Object>> entries = map.entrySet();  
        var entries = map.entrySet();  
    }  
}
```

局部变量类型推断不适用场景：

1. 声明一个成员变量。
2. 声明一个数组变量，并为数组静态初始化（省略new的情况下）。
3. 方法的返回值类型。
4. 方法的参数类型。
5. 没有初始化的方法内的局部变量声明。
6. 作为catch块中异常类型。
7. Lambda表达式函数式接口的类型。
8. 方法引用中函数式接口的类型。

**模式匹配：`instanceof`**

> JDK14中预览特性
> JDK15中第二次预览
> JDK16中转正特性

```java
public class MainTest {  
    public static void main(String[] args) {  
        test1();  
        test2();  
    }  
  
    // JDK14之前  
    public static void test1() {  
        Object obj = new String("hello world");  
        if (obj instanceof String) {  
            String str = (String) obj;  
            System.out.println(str);  
        } else {  
            System.out.println("不是String类型");  
        }  
    }  
  
    // JDK14 判断并转化赋值  
    public static void test2() {  
        Object obj = new String("hello world");  
        if (obj instanceof String str) {  
            System.out.println(str);  
        } else {  
            System.out.println("不是String类型");  
        }  
    }  
}
```

**switch表达式**

> JDK12中预览特性
> JDK13中第二次预览
> JDK14中转正特性
> JDK17中预览特性：switch的模式匹配

传统switch声明语句的弊端：

- 匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行；case穿透。
- 所有case语句共用一个块范围，在不同的case语句定义的变量不能重复。
- 不能在一个case里写多个执行结果一致的条件。
- 整个switch不能作为表达式返回值。


JDK12中对switch声明语句进行扩展，使用 `case C ->` 来替代 `break`，省去了beak语句，避免因为少写而出错。同时将多个 `case` 合并到一行。为了保持兼容型，case条件语句中依然可以使用字符 `:` ，但在同一个switch结构里不能混用 `->` 和 `:` 否则会提示编译错误。

```java
public class MainTest {  
    public static void main(String[] args) {  
        test1();  
        test2();  
        test3();  
        test4("hello world");  
        test5("hello world");  
    }  
  
    // JDK12之前  
    public static void test1() {  
        Week day = Week.MONDAY;  
        switch (day) {  
            case MONDAY:  
                // int num=0;  
                System.out.println("星期一");  
                break;  
            case TUESDAY:  
                // int num=10; // 报错不能定义相同的变量名  
                System.out.println("星期二");  
                break;  
            case WEDNESDAY:  
                System.out.println("星期三");  
                break;  
            case THURSDAY:  
                System.out.println("星期四");  
                break;  
            case FRIDAY:  
                System.out.println("星期五");  
                break;  
            case SATURDAY:  
                System.out.println("星期六");  
                break;  
            case SUNDAY:  
                System.out.println("星期日");  
                break;  
            default:  
                System.out.println("输入有误");  
                break;  
        }  
    }  
  
    // JDK12 使用 -> 替换 : ，接收结果  
    public static void test2() {  
        Week day = Week.MONDAY;  
        switch (day) {  
            case MONDAY -> {  
                int i = 1;  
                System.out.println("星期一");  
            }  
            case TUESDAY -> {  
                int i = 1;  
                System.out.println("星期二");  
            }  
            case WEDNESDAY -> System.out.println("星期三");  
            case THURSDAY -> System.out.println("星期四");  
            case FRIDAY -> System.out.println("星期五");  
            case SATURDAY, SUNDAY -> System.out.println("休息日");  
            default -> System.out.println("输入有误");  
        }  
  
        String str = switch (day) {  
            case MONDAY -> "星期一";  
            case TUESDAY -> "星期二";  
            case WEDNESDAY -> "星期三";  
            case THURSDAY -> "星期四";  
            case FRIDAY -> "星期五";  
            case SATURDAY, SUNDAY -> "休息日";  
            default -> "输入有误";  
        };  
        System.out.println(str);  
    }  
  
    // JDK13 引入yield关键字，用于switch表达式的返回值  
    public static void test3() {  
        Week day = Week.MONDAY;  
        String str = switch (day) {  
            case MONDAY -> {  
                int i = 1;  
                yield "星期一";  
            }  
            case TUESDAY -> {  
                yield "星期二";  
            }  
            case WEDNESDAY -> {  
                yield "星期三";  
            }  
            case THURSDAY -> "星期四";  
            case FRIDAY -> "星期五";  
            case SATURDAY, SUNDAY -> "休息日";  
            default -> "输入有误";  
        };  
        System.out.println(str);  
    }  
  
    // JDK17之前  
    public static String test4(Object o) {  
        String format = "unknown";  
        if (o instanceof Integer i) {  
            format = String.format("Integer: %d", i);  
        } else if (o instanceof Long l) {  
            format = String.format("Long: %d", l);  
        } else if (o instanceof Double d) {  
            format = String.format("Double: %f", d);  
        } else if (o instanceof String s) {  
            format = String.format("String: %s", s);  
        }  
        return format;  
    }  
  
    // JDK17  
    public static String test5(Object o) {  
        return switch (o) {  
            case Integer i -> String.format("Integer: %d", i);  
            case Long l -> String.format("Long: %d", l);  
            case Double d -> String.format("Double: %f", d);  
            case String s -> String.format("String: %s", s);  
            default -> "unknown";  
        };  
    }  
}  
  
enum Week {  
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY  
}
```

**文本块**

> JDK13预览特性
> JDK14二次预览
> JDK15功能转正

```java
public class MainTest {  
    public static void main(String[] args) {  
        test1();  
        test2();  
    }  
  
    // JDK13之前  
    public static void test1() {  
        String info = "<html>\n" +  
                "   <body>\n" +  
                "       <h1>Hello World</h1>\n" +  
                "   </body>\n" +  
                "</html>";  
        System.out.println(info);  
    }  
  
    // JDK13  
    public static void test2() {  
        String info = """  
                <html>                   
	                <body>                       
		                <h1>Hello World</h1>                   
		            </body>                
		        </html>                
		        """;  
        System.out.println(info);  
    }  
        
    // JDK14：\：取消换行操作；\s：表示一个空格
    public static void test3() {  
        String info = """  
                <html> \
	                <body>
		                <h1>H\sello World</h1>
		            </body>
		        </html>            
		        """;  
        System.out.println(info);  
    }  
}
```

**record记录**

> JDK14预览特性
> JDK15二次预览
> JDK16功能转正

record是提供一种将数据建模为数据的好方法，它不是JavaBeans的直接替代品。因为其方法不符合JavaBeans的get标准。另外JavaBeans通常是可变的，而记录是不可变的。

```java
import java.util.Objects;  
  
public class Person {  
    private final String code;  
    private final String name;  
  
    public Person(String code, String name) {  
        this.code = code;  
        this.name = name;  
    }  
  
    public String code() {  
        return code;  
    }  
  
    public String name() {  
        return name;  
    }  
  
    @Override  
    public boolean equals(Object o) {  
        if (this == o) return true;  
        if (o == null || getClass() != o.getClass()) return false;  
        Person person = (Person) o;  
        return Objects.equals(code, person.code) && Objects.equals(name, person.name);  
    }  
  
    @Override  
    public int hashCode() {  
        return Objects.hash(code, name);  
    }  
  
    @Override  
    public String toString() {  
        return "Person{" +  
                "code='" + code + '\'' +  
                ", name='" + name + '\'' +  
                '}';  
    }  
}

public record Person1(String code, String name) {  
    // 可以在声明的类中定义静态字段，静态方法，构造器或实例方法。  
    static String info = "tip:提示信息";  
  
    public static void showInfo() {  
        System.out.println(info);  
    }  
  
    public Person1() {  
        this("000", "未知");  
    }  
  
    // 不能在record声明的类中定义实例字段，类不能声明为abstract；不能声明显示的父类，其父类就是Record；record类是一个final类型  
    // int i=1;  
}  
  
// abstract record  animal(String name) {}  
// record Cat(String name) extends Thread {}  
// class Student extends Person1{}

public class MainTest {  
    public static void main(String[] args) {  
        Person person = new Person("001", "张三");  
        Person1 person1 = new Person1("001", "张三");  
        System.out.println(person.equals(person1));  
        // class java.lang.Record  
        System.out.println(person1.getClass().getSuperclass());  
    }  
}
```

**密封类**

> JDK15预览特性
> JDK16二次预览
> JDK17功能转正

sealed修饰的类可以指定子类，这样这个类只能被指定的子类继承。

通过密封的类和接口来限制超类的使用，密封的类和接口限制其他可能继承或实现它们的其它类或接口。

具体使用：

- 使用修饰符 `sealed` ，可以将一个类声明为密封类。密封的类使用保留关键字 `permits` 列出可以直接扩展（即extends）它的类。
- `sealed` 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 `final`、`sealed`、`non-sealed`三者之一。

```java
public sealed class Animal permits Dog, Cat, Bird {  
}  
  
// 子类必须是 final、sealed、non-sealed三者之一  
final class Dog extends Animal { // Dog不能被再继承  
}  
  
sealed class Cat extends Animal permits BlackCat, WhiteCat {  
}  
  
non-sealed class Bird extends Animal { // Bird再继承时没有任何限制  
}  
  
// 其他辅助类  
final class BlackCat extends Cat {  
}  
  
non-sealed class WhiteCat extends Cat {  
}  
  
class BlackBird extends Bird {  
}
```

### 7. API变化

**Optional类**

> JDK8新特性

Optional类，通过检查空值的方式避免空指针异常。

`Optional<T>` 类（java.util.Optional）是一个容器类，它可以保存类型T的值，代表这个这个值存在，或者仅仅保存null，表示这个值不存在。如果值存在，则`isPersent()`方法返回true，调用 `get()` 方法返回该对象。

Optional提供空值检测方法：

- 创建Optional类对象方法：
	- `static <T> Optional<T> empty()`：用来创建一个空的Optional实例。
	- `static <T> Optional<T> of(T value)`：用来创建一个空的Optional实例，value必须非空。
	- `static <T> Optional<T> ofNullable(T value)`：用来创建一个空的Optional实例，value可能非空，也可能为空。
- 判断Optional容器是否包含空对象：
	- `boolean isEmpty()`：判断Optional容器中的值是否为空。
	- `boolean isPersent()`：判断Optional容器中的值是否存在。
	- `void ifPersent(Consumer<? super T> consumer)`：判断Optional容器中的值是否存在，如果存在就进行consumer指定的操作，如果不存在就不做任何操作。
- 获取Optional容器的对象：
	- `T get()`：如果调用对象包含值，返回该值；否则跑出异常。`T get()` 与 `of(T value)` 配合使用。
	- `T orElse(T other)`：`orElse(T other)` 与 `ofNullable(T value)` 配合使用，如果Optional容器中非空，返回所包装值，如果为空，就用 `orElse(T other)` 中other指定的默认值代替。
	- `T orElseGet(Suppler<? extends T> other)`：如果Optional容器中非空，就返回包装值，如果为空，就用Suppler接口中的Lambda表达式提供的值代替。
	- `T orElseThrow(Suppler<? extends x> exceptionSupplier)`：如果Optional容器中非空，就返回包装值，如果为空，就用指定的异常类型代替原来的NoSuchElementException。

```java
import java.util.Optional;  
  
public class MainTest {  
    public static void main(String[] args) {  
        String star = "*";  
        star = null;  
        Optional<String> optional = Optional.ofNullable(star);  
        String twoStar = "**";  
        String finalStar = optional.orElse(twoStar);  
        System.out.println(finalStar);  
    }  
}
```

**String存储结构和API变更**

> JDK9的新特性

String从 `char[]` 存储结构替换为 `byte[]`，加上编码标记，节约了存储空间。

StringBuffer 和 StringBuilder也从 `char[]` 存储结构替换为 `byte[]`。

JDK11新特性：新增了一系列字符串处理方法

| 举例                                            | 描述         |
| --------------------------------------------- | ---------- |
| `"".isBlank() // true`                        | 判断字符串是否为空白 |
| `" JavaStack ".strip() // JavaStack`          | 去除首尾空白     |
| `" JavaStack ".stripTrailing() // JavaStack ` | 去除首部空格     |
| `" JavaStack ".stripLeading() //  JavaStack`  | 去除尾部空格     |
| `"Java".repeat(2) // JavaJava`                | 复制字符串      |
| `"A\nb\nC\nd".lines().count() // 4`           | 行数统计       |

JDK12新特性：String实现了Constable接口

```java
public final class String  
    implements java.io.Serializable, Comparable<String>, CharSequence,  
               Constable, ConstantDesc { // todo()...
               }
```

```java
import java.util.Optional;  
  
public class MainTest {  
    public static void main(String[] args) {  
        String star = "*";  
        // 调用Optional.of方法返回一个Optional类型
        Optional<String> optional = star.describeConstable();  
        System.out.println(optional.orElse("default"));  
    }  
}
```

JDK12新特性：String新增方法

```java
public class MainTest {  
    public static void main(String[] args) {  
        // 在某些情况下，该方法被称为map()  
        var result = "demo".transform(input -> input + " MainTest");  
        System.out.println(result);  
  
        var result1 = "demo".transform(input -> input + " MainTest").transform(String::toUpperCase);  
        System.out.println(result1);  
    }  
}
```

**Applet API**

> JDK17标记删除

Applet API提供了一种将Java AWT/Swing控件嵌入到浏览器网页中的方法。在JDK9时标记为过时，JDK17标为删除。

### 8. 结构变化

**UnderScore（下划线）使用的限制**

> JDK9

在JDK8中，标识符可以独立使用 `_` 来命名。但是在JDK9中规定 `_` 不再可以单独命名标识符，如果使用，回报错。

**更简化的编译运行程序**

> JDK11

在JDK11版本中，通过 `java java源文件` 可直接运行Java程序。省略了先编译再运行过程，但一步运行时没有 `.class` 文件生成的。

```java
// JDK11之前
// 编译
javac Demo.java
// 运行
java Demo

// JDK11
java Demo.java
```

**GC方面新特性**：

- JDK8使用的垃圾回收器是Parallel GC。
- JDK9以后默认的垃圾回收器是G1 GC。
- JDK10为G1提供并行的Full GC。
- JDK12可中断G1 Mixed GC。
- JDK12增强G1，自动返回未用堆内存给操作系统

G1最大的优势就是可以尽量的避免full GC。在JDK10之前单线程版的标记-清除-压缩算法被用于full GC。为了尽量减少full GC带来的影响，在JDK10时就把之前单线程版的full GC算法改成了支持多个线程同时full GC，从而减少了full GC带来的停顿，提高性能。

通过 `-XX:ParallelGCThreads` 参数来指定用于并行GC的线程数。

Shenandoah GC：JDK12，低停顿时间的GC。由Red Hat发布，针对JVM上内存回收实现低停顿的需求。

ZGC：JDK11，是一个并发、基于region、压缩性的垃圾收集器。目标是支持TB级容量，暂停的时间低，对整个程序吞吐量的影响小于15%，还可扩展实现机制。

ZGC：JDK13，将未使用的堆内存归还给操作系统。

ZGC：JDK14，支持Mac或Windows，在之前仅支持Linux。使用方法 `-XX:+UnlockExperimentalVMOptions -XX:UseZGC`。

ZGC与Shenandoah GC目标高度相似的，尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小都可以把垃圾收集的停顿时间限制在是毫秒以内的低延迟。

ZGC：JDK15，功能转正。JDK默认的垃圾回收还是G1 GC。使用时，需要配置 `-XX:UseZGC` 就可以。

ZGC：JDK16，并发线程处理。保证Java线程可以在GC safepoints的同时可以并发执行。有主意提高Java软件应用程序的性能和效率。
