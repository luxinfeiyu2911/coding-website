---
文章分类:
  - 计算机基础知识
文章标签:
  - 理论
  - Java
文章简介: Java的File类与IO流，熟悉文件对象和各种流的使用
文章精选:
  - 否
是否发布:
  - 否
发布时间: 
创建时间: 2024-11-10
修改时间: 2024-11-16
---

### 1. File类实例化与常用方法

File类位于`java.io`包下。 File类的一个对象，对应与操作系统的一个文件或文件目录。

File类中声明了文件信息、获取文件列表、文件重命名、文件判断、文件创建和删除方法。

File类的对象，通常是作为IO流操作的文件端点。将File类的对象作为参数传递到IO流相关的构造器中。

**File类的构造器**：

| 方法                                         | 含义                                                               |
| :----------------------------------------- | ---------------------------------------------------------------- |
| `public File(String pathname)`             | 通过pathname路径创建，可以事相对路径也可以是绝对路径。如果是相对路径，则默认的当前路径在系统属性user.dir中存储。 |
| `public File(String parent, String child)` | 以parent为父路径，child为子路径创建File对象。                                   |
| `public File(File parent, String child)`   | 根据父File对象和子文件路径创建File对象。                                         |

```java
package org.file;  
  
import java.io.File;  
  
public class FileTest1 {  
  
    public static void main(String[] args) {  
        test1();  
        test2();  
        test3();  
    }  
  
    /** 测试File类的构造方法：public File(String pathname)  
     * 文件路径的表示：  
     * 1. 绝对路径：以磁盘的根目录为起点，表示文件或目录的绝对位置。  
     * 2. 相对路径：以当前目录为起点，表示文件或目录的相对位置。  
     *    在Idea编辑器中，单元测试方法是相对于当前module的。main()方法是相对于当前项目的。  
     * 3. 路径分隔符：在Windows系统中，路径分隔符为“\”，在Linux系统中，路径分隔符为“/”。  
     */  
    public static void test1() {  
        File file1 = new File("D:/test/file1.txt");  
        File file2 = new File("fileDirectory");  
        System.out.println(file2.getAbsoluteFile());  
    }  
  
    /** 测试File类的构造方法：public File(String parent, String child)  
     * 父路径和子路径的组合：  
     * 1. 父路径：父路径可以是绝对路径，也可以是相对路径。  
     * 2. 子路径：子路径可以是文件名，也可以是目录名。  
     * 3. 路径分隔符：在Windows系统中，路径分隔符为“\”，在Linux系统中，路径分隔符为“/”。  
     * */  
    public static void test2() {  
        File file1 = new File("D:/test", "file1.txt");  
        File file2 = new File("fileDirectory", "");  
        System.out.println(file2.getAbsoluteFile());  
    }  
  
    /** 测试File类的构造方法：public File(File parent, String child)  
     * 父路径和子路径的组合：  
     * 1. 父路径：父路径可以是绝对路径，也可以是相对路径。  
     * 2. 子路径：子路径可以是文件名，也可以是目录名。  
     * 3. 路径分隔符：在Windows系统中，路径分隔符为“\”，在Linux系统中，路径分隔符为“/”。  
     * */  
    public static void test3() {  
        File fileParent1 = new File("D:/test/");  
        File file1 = new File(fileParent1, "file1.txt");  
        File fileParent2 = new File("fileDirectory");  
        File file2 = new File(fileParent2, "");  
        System.out.println(file2.getAbsoluteFile());  
    }  
}
```

文件路径的表示：  

- 绝对路径：以磁盘的根目录为起点，表示文件或目录的绝对位置。  
- 相对路径：以当前目录为起点，表示文件或目录的相对位置。在Idea编辑器中，单元测试方法是相对于当前module的。main()fang方法是相对于当前项目的。

**File类的常用方法**：获取文件和目录的基本信息

| 方法                         | 含义                            |
| :------------------------- | ----------------------------- |
| `String getName()`         | 获取文件或目录的名称。                   |
| `String getPath()`         | 获取文件或目录的路径。                   |
| `String getAbsolutePath()` | 获取绝对路径。                       |
| `File getAbsoluteFile()`   | 获取绝对路径对应的File对象。              |
| `String getParent()`       | 获取上层文件目录路径。如果没有，返回null。       |
| `long length()`            | 获取文件长度（字节数），如果File是文件目录返回值为0。 |
| `long lastModified()`      | 获取最后修改时间。返回一个毫秒值。             |

```java
package org.file;  
  
import java.io.File;  
  
public class FileTest2 {  
  
    public static void main(String[] args) {  
        test1();  
    }  
  
    /** File类的常用方法：获取文件和目录的基本信息  
     * 1. getName()：获取文件或目录的名称  
     * 2. getPath()：获取文件或目录的路径  
     * 3. getAbsolutePath()：获取绝对路径  
     * 4. getAbsoluteFile()：获取绝对路径对应的File对象  
     * 5. getParent()：获取上层文件目录路径  
     * 6. length()：获取文件长度  
     * 7. lastModified()：获取最后修改时间  
     */  
    public static void test1() {  
        File file1 = new File("D:/test/file1.txt");  
        System.out.println("文件名：" + file1.getName());  
        System.out.println("文件路径：" + file1.getPath());  
        System.out.println("绝对路径：" + file1.getAbsolutePath());  
        System.out.println("绝对路径对应的File对象：" + file1.getAbsoluteFile());  
        System.out.println("父目录：" + file1.getParent());  
        System.out.println("文件长度：" + file1.length());  
        System.out.println("最后修改时间：" + file1.lastModified());  
    }  
}
```

**File类的常用方法**：列出当前目录的下一级文件和目录

| 方法                   | 含义                            |
| :------------------- | ----------------------------- |
| `String[] list()`    | 列出当前目录的下一级文件和目录，返回一个String数组。 |
| `File[] listFiles()` | 列出当前目录的下一级文件和目录，返回一个File数组。   |

```java
package org.file;  
  
import java.io.File;  
  
public class FileTest2 {  
  
    public static void main(String[] args) {  
        test2();  
    }  
  
    /** File类的常用方法：列出当前目录的下一级文件和目录  
     * 1. list()：列出当前目录的下一级文件和目录，返回一个String数组  
     * 2. listFiles()：列出当前目录的下一级文件和目录，返回一个File数组  
     */  
    public static void test2() {  
        File file = new File("D:/test");  
        // 列出当前目录的下一级文件和目录，返回一个String数组  
        String[] list = file.list();  
        for (String s : list) {  
            System.out.println(s);  
        }  
  
        // 列出当前目录的下一级文件和目录，返回一个File数组  
        File[] listFiles = file.listFiles();  
        for (File f : listFiles) {  
            System.out.println(f.getName());  
        }  
    }  
}
```

**File类的常用方法**：File类重命名

| 方法                            | 含义                                           |
| :---------------------------- | -------------------------------------------- |
| `boolean renameTo(File dest)` | 命名文件或目录，返回boolean值，true表示重命名成功，false表示重命名失败。 |

```java
package org.file;  
  
import java.io.File;  
  
public class FileTest2 {  
  
    public static void main(String[] args) {  
        test3();  
    }  

    /** File类的常用方法：文件重命名  
     * 1. renameTo()：重命名文件或目录，返回boolean值，true表示重命名成功，false表示重命名失败  
     * 保证文件重命名成功的条件：  
     *      1. 重命名的文件或目录必须存在  
     *      2. 重命名的文件或目录不能与目标文件或目录重名，即目标文件或目录不能存在  
     *      3. 目标文件或目录的上层目录必须存在  
     * */  
    public static void test3() {  
        File file1 = new File("D:/test/file1.txt");  
		File file2 = new File("D:/test/file1_rename.txt");
        boolean renameTo = file1.renameTo(file2);  
        System.out.println(renameTo);  
        File fileDirectory1 = new File("D:/test/fileDirectory");  
        File fileDirectory2 = new File("D:/test/fileDirectory_rename");  
        boolean renameDirectoryTo = fileDirectory1.renameTo(fileDirectory2);  
        System.out.println(renameDirectoryTo);    
    }
}
```

**File类的常用方法**：判断文件功能的方法

| 方法                      | 含义           |
| :---------------------- | ------------ |
| `boolean exists()`      | 判断文件或目录是否存在。 |
| `boolean isDirectory()` | 判断是否为目录。     |
| `boolean isFile()`      | 判断是否为文件。     |
| `boolean canRead()`     | 判断文件是否可读。    |
| `boolean canWrite()`    | 判断文件是否可写。    |
| `boolean isHidden()`    | 判断文件是否隐藏。    |

```java
package org.file;  
  
import java.io.File;  
  
public class FileTest2 {  
  
    public static void main(String[] args) {  
        test4();  
    }  

    /** File类的常用方法：判断文件功能的方法  
     * 1. exists()：判断文件或目录是否存在  
     * 2. isDirectory()：判断是否为目录  
     * 3. isFile()：判断是否为文件  
     * 4. canRead()：判断文件是否可读  
     * 5. canWrite()：判断文件是否可写  
     * 6. isHidden()：判断文件是否隐藏  
     * */  
	public static void test4() {  
	    File file1 = new File("D:/test/file1.txt");  
	    System.out.println("file1.txt 相关信息：");  
	    System.out.println("文件是否存在：" + file1.exists());  
	    System.out.println("是否为目录：" + file1.isDirectory());  
	    System.out.println("是否为文件：" + file1.isFile());  
	    System.out.println("文件是否可读：" + file1.canRead());  
	    System.out.println("文件是否可写：" + file1.canWrite());  
	    System.out.println("文件是否隐藏：" + file1.isHidden());  
	  
	    File fileDirectory = new File("D:/test/fileDirectory");  
	    System.out.println("fileDirectory 相关信息：");  
	    System.out.println("文件是否存在：" + fileDirectory.exists());  
	    System.out.println("是否为目录：" + fileDirectory.isDirectory());  
	    System.out.println("是否为文件：" + fileDirectory.isFile());  
	    System.out.println("文件是否可读：" + fileDirectory.canRead());  
	    System.out.println("文件是否可写：" + fileDirectory.canWrite());  
	    System.out.println("文件是否隐藏：" + fileDirectory.isHidden());  
	}
}
```

**File类的常用方法**：文件创建、删除的方法

| 方法                                           | 含义                                    |
| :------------------------------------------- | ------------------------------------- |
| `boolean createNewFile() throws IOException` | 创建文件，如果文件已存在，则抛出IOException异常。        |
| `boolean mkdir()`                            | 创建目录，如果目录已存在，则返回false，否则返回true。       |
| `boolean mkdirs()`                           | 创建目录，如果目录不存在，则创建所有上层目录，否则返回false。     |
| `boolean delete()`                           | 删除文件或目录，如果文件或目录不存在，则返回false，否则返回true。 |

```java
package org.file;  
  
import java.io.File;  
  
public class FileTest2 {  
  
    public static void main(String[] args) {  
        test5();  
    }  

    /** File类的常用方法：文件创建、删除的方法  
     * 1. createNewFile()：创建文件，如果文件已存在，则抛出IOException异常  
     * 2. mkdir()：创建目录，如果目录已存在，则返回false，否则返回true  
     * 3. mkdirs()：创建目录，如果目录不存在，则创建所有上层目录，否则返回false  
     * 4. delete()：删除文件或目录，如果文件或目录不存在，则返回false，否则返回true  
     * 注释事项：  
     *      1. 删除后，文件会直接从磁盘上消失，无法恢复，请谨慎使用  
     *      2. 要删除一个目录，必须先删除其下面的所有文件和目录，目录下不能有文件或目录  
     */  
    public static void test5() {  
        // 创建文件\删除文件  
        File file1 = new File("D:/test/file2.txt");  
        if (!file1.exists()) {  
            try {  
                // 创建文件  
                boolean isCreateNewFileSuccess = file1.createNewFile();  
                if (isCreateNewFileSuccess) {  
                    System.out.println("创建文件成功！");  
                } else {  
                    System.out.println("创建文件失败！");  
                }            } catch (Exception e) {  
                e.printStackTrace();
            }
        } else {  
            System.out.println("文件已存在！");  
            // 删除文件  
            boolean isFileDeleteSuccess = file1.delete();  
            if (isFileDeleteSuccess) {  
                System.out.println("删除文件成功！");  
            } else {  
                System.out.println("删除文件失败！");  
            }        }  
        // 创建目录  
        File fileDirectory = new File("D:/test/fileDirectory/newDirectory");  
        if(fileDirectory.getParentFile().exists()){  
            System.out.println("父目录存在！");  
            // 创建目录,上层目录必须存在  
            boolean isDirectoryMkdirSuccess = fileDirectory.mkdir();  
            if(isDirectoryMkdirSuccess){  
                System.out.println("创建目录成功！");  
            }else {  
                System.out.println("创建目录失败！");  
            }        }else{  
            System.out.println("父目录不存在！");  
            // 创建目录,创建所有上层目录  
            boolean isDirectoryMkdirsSuccess = fileDirectory.mkdirs();  
            if(isDirectoryMkdirsSuccess){  
                System.out.println("创建目录成功！");  
            }else {  
                System.out.println("创建目录失败！");  
            }        
        }    
    }
}
```

**File常见场景**：

1. 输出当前文件及其子文件。
2. 计算文件下所有文件大小。
3. 删除文件及其子文件。

```java
package org.file;  
  
import java.io.File;  
  
public class FileTest3 {  
  
    public static void main(String[] args) {  
        test1();  
        test2();  
        test3();  
    }  
  
    // 输出当前文件及其子文件  
    public static void test1() {  
        File file = new File("D:/test");  
        printFileName(file);  
    }  
  
    public static void printFileName(File file) {  
        if (file.isFile()) {  
            System.out.println(file.getAbsolutePath());  
        } else {  
            // listFiles()排序：先文件，再文件夹。  
            File[] files = file.listFiles();  
            for (File f : files) {  
                printFileName(f);  
            }  
        }  
    }  
  
    // 计算文件下所有文件的大小  
    public static void test2() {  
        File file = new File("D:/test");  
        Long totalSize = calculateFileName(file);  
        System.out.println(totalSize);  
    }  
  
    public static Long calculateFileName(File file) {  
        if (file.isFile()) {  
            return file.length();  
        } else {  
            long totalSize = 0;  
            File[] files = file.listFiles();  
            if (files != null) {  
                for (File f : files) {  
                    totalSize += calculateFileName(f);  
                }  
            }  
            return totalSize;  
        }  
    }  
  
    // 删除文件及其子文件  
    public static void test3() {  
        File file = new File("D:/test");  
        deleteFileIncludeChild(file);  
    }  
  
    public static void deleteFileIncludeChild(File file) {  
        if(file.isDirectory()) {  
            File[] files = file.listFiles();  
            if (files != null) {  
                for (File f : files) {  
                    deleteFileIncludeChild(f);  
                }  
            }  
        }  
        file.delete();  
    }  
}
```

### 2. IO流的概述与分类

在Java程序中，对于数据的输入/输出操作都是以“流（stream）”的方式进行。I/O流中I/O是Input/Output的缩写，I/O技术用于设备之间的数据传输。例如：读写文件，网络通信。

**流的分类**：

1. 按照数据流向分类：输入流/输出流。
	- 输入流：用于从其他设备读取数据到内存中的流，通常以 `InputStream` 或 `Reader` 结尾。
	- 输出流：用于将数据从内存中写入到其他设备上的流，通常以 `OutputStream` 或 `Writer` 结尾。
2. 按操作的数据单位分类：字节流/字符流。
	- 字节流：以字节为单位读写数据的流，通常以 `InputStream` 和 `OutputStream` 结尾。  
	- 字符流：以字符为单位读写数据的流，通常以 `Reader` 和 `Writer` 结尾。
3. 按照IO流的角色分类：节点流/处理流。
	- 节点流：直接从数据源或目的地读写数据。
	- 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通常对数据进行处理，为程序提供更强大的读写功能。

**流的API**：

在Java中，IO流共涉及40多个类，这些类都是从以下4个抽象基类派生的：

| 抽象基类 |      输入流      |      输出流       |
| :--: | :-----------: | :------------: |
| 字节流  | `InputStream` | `OutputStream` |
| 字符流  |   `Reader`    |    `Writer`    |

这些抽象基类派生出了多个子类：

| 分类       | 字节输入流                  | 字节输出流                   | 字符输入流               | 字符输出流                |
| :------- | :--------------------- | :---------------------- | :------------------ | :------------------- |
| ==抽象基类== | `InputStream`          | `OutputStream`          | `Reader`            | `Writer`             |
| ==访问文件== | `FileInputStream`      | `FileOutputStream`      | `FileReader`        | `FileWriter`         |
| 访问数组     | `ByteArrayInputStream` | `ByteArrayOutputStream` | `ByteArrayReader`   | `ByteArrayWriter`    |
| 访问管道     | `PipedInputStream`     | `PipedOutputStream`     | `PipedReader`       | `PipedWriter`        |
| 访问字符串    |                        |                         | `StringReader`      | `StringWirter`       |
| ==缓冲流==  | `BufferedInputStream`  | `BufferedOutputStream`  | `BufferedReader`    | `BufferedWriter`     |
| ==转换流==  |                        |                         | `InputStreamReader` | `OutputStreamWriter` |
| ==对象流==  | `ObjectInputStream`    | `ObjectOutputStream`    |                     |                      |
|          | `FilterInputStream`    | `FilterOutputStream`    | `FilterReader`      | `FilterWriter`       |
| 打印流      |                        | `PrintOutputStream`     |                     | `PrintWriter`        |
| 推回输入流    | `PushbackInputStream`  |                         | `PushbackReader`    |                      |
| 特殊流      | `DataInputStream`      | `DataOutputStream`      |                     |                      |

### 3. FileReader读取和FileWriter写出文本数据

**FileReader读取和FileWriter写出文本数据的步骤**：

1. 创建读取或写出File类的对象。
2. 创建输入流或输出流，接收File类的对象。
3. 具体的读入或写出过程：
	- 读取：`int read(char cbuf[])`。
	- 写出：`write(String str)`和`void write(char cbuf[], int off, int len)`。
4. 关闭流资源，避免内存泄露。

注意点：

- 在涉及流资源的关闭操作中，需要使用try-catch-finally方法来处理异常。
- 对于输入流来说，File类的对象对应的物理磁盘文件必须存在。否则会报`FileNotFoundException`错误。
- 对于输出流来说，File类的对象对应的物理磁盘文件可以不存在。
	- 如果文件不存在，则在输出过程中会自动创建文件，并写出数据。
	- 如果文件存在，使用`FileWriter(File file)`或`FileWirter(File file,false)`，输出数据过程中，会新建同名的文件并覆盖现有内容。使用`FileWirter(File file,true)`，则会在现有文件的末尾追加写出内容。

```java
package org.file;  
  
import java.io.*;  
  
public class FileTest4 {  
  
    public static void main(String[] args) throws IOException {  
        // FileReader的使用  
        test1();  
        test2();  
        // FileWriter的使用  
        test3();  
        test4();  
        // FileReader和FileWriter的结合使用  
        test5();  
    }  
  
    /** 使用FileReader读取文件内容，并输出到控制台  
     * 1. 创建文件对象，当文件端点，传输给FileReader  
     * 2. 创建FileReader对象  
     * 3. 读取文件内容，并输出到控制台  
     * 4. 关闭FileReader对象  
     * */  
    public static void test1() throws IOException {  
        // 1. 创建文件对象，当文件端点，传输给FileReader  
        File file = new File("info.properties");  
        // 2. 创建FileReader对象  
        FileReader fReader = new FileReader(file);  
        // 3. 读取文件内容，并输出到控制台  
        int data = fReader.read();  
        while (data != -1) {  
            System.out.print((char) data);  
            data = fReader.read();  
        }  
        // 4. 关闭FileReader对象  
        fReader.close();  
    }  
  
    /** 使用FileReader读取文件内容，并输出到控制台（完整版）  
     * 1. 创建文件对象，当文件端点，传输给FileReader  
     * 2. 创建FileReader对象  
     * 3. 读取文件内容，并输出到控制台  
     * 4. 关闭FileReader对象  
     * */  
    public static void test2() {  
        FileReader fReader = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileReader  
            File file = new File("info.properties");  
            // 2. 创建FileReader对象  
            fReader = new FileReader(file);  
            // 3. 读取文件内容，并输出到控制台  
            char[] buffer = new char[1024];  
            int len;  
            while ((len = fReader.read(buffer)) != -1) {  
                System.out.print(new String(buffer, 0, len));  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                if (fReader != null) {  
                    // 4. 关闭FileReader对象  
                    fReader.close();  
                }  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
  
    /** 使用FileWriter写入文件内容（完整版）  
     * 1. 创建文件对象，当文件端点，传输给FileWriter  
     * 2. 创建FileWriter对象  
     * 3. 写入文件内容  
     * 4. 关闭FileWriter对象  
     * FileWriter的构造方法：  
     * 1. FileWriter(File file)：  
     *      - 如果文件不存在，则创建文件  
     *      - 如果文件存在，则覆盖原文件内容  
     * 2. FileWriter(File file, boolean append)：  
     *      - 如果append为true，则在文件末尾追加内容  
     *      - 如果append为false，则覆盖原文件内容  
     * */  
    public static void test3() throws IOException {  
        // 1. 创建文件对象，当文件端点，传输给FileWriter  
        File file = new File("info1.properties");  
        // 2. 创建FileWriter对象  
        FileWriter fWriter = new FileWriter(file);  
        // 3. 写入文件内容  
        fWriter.write("name=zhangsan\n");  
        fWriter.write("age=19\n");  
        // 4. 关闭FileWriter对象  
        fWriter.close();  
    }  
  
    /** 使用FileWriter写入文件内容（完整版）  
     * 1. 创建文件对象，当文件端点，传输给FileWriter  
     * 2. 创建FileWriter对象  
     * 3. 写入文件内容  
     * 4. 关闭FileWriter对象  
     * FileWriter的构造方法：  
     * 1. FileWriter(File file)：  
     *      - 如果文件不存在，则创建文件  
     *      - 如果文件存在，则覆盖原文件内容  
     * 2. FileWriter(File file, boolean append)：  
     *      - 如果append为true，则在文件末尾追加内容  
     *      - 如果append为false，则覆盖原文件内容  
     * */  
    public static void test4() {  
        FileWriter fWriter = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileWriter  
            File file = new File("info1.properties");  
            // 2. 创建FileWriter对象  
            fWriter = new FileWriter(file);  
            // 3. 写入文件内容  
            fWriter.write("name=zhangsan\n");  
            fWriter.write("age=20\n");  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                if (fWriter != null) {  
                    // 4. 关闭FileWriter对象  
                    fWriter.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
  
    /** 使用FileReader和FileWriter读写文件内容（完整版）  
     * 1. 创建文件对象，当文件端点，传输给FileReader和FileWriter  
     * 2. 创建FileReader对象和FileWriter对象  
     * 3. 使用FileReader读取文件内容，并写入FileWriter对象  
     * 4. 关闭FileReader和FileWriter对象  
     * */  
    public static void test5() {  
        FileReader fReader = null;  
        FileWriter fWriter = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileReader和FileWriter  
            File srcFile = new File("info.properties");  
            File destFile = new File("info1.properties");  
            // 2. 创建FileReader对象和FileWriter对象  
            fReader = new FileReader(srcFile);  
            fWriter = new FileWriter(destFile);  
            // 3. 读写文件内容  
            char[] buffer = new char[1024];  
            int len;  
            while ((len = fReader.read(buffer)) != -1) {  
                //write(char[] cbuf, int off, int len)，将字符数组写入文件  
                //write(char[] cbuf)，将字符数组写入文件，可能会存在数组末尾有上次的内容  
                fWriter.write(buffer, 0, len);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭FileReader和FileWriter对象  
            try {  
                if (fWriter != null) {  
                    fWriter.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (fReader != null) {  
                    fReader.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

### 4. FileInputStream读取和FileOutputStream写出数据

**FileInputStream读取和FileOutputStream写出数据的步骤**：

1. 创建读取或写出File类的对象。
2. 创建输入流或输出流，接收File类的对象。
3. 具体的读入或写出过程：
	- 读取：`int read(byte b[])`。
	- 写出：`void write(byte b[], int off, int len)`。
4. 关闭流资源，避免内存泄露。

注意点：

- 在涉及流资源的关闭操作中，需要使用try-catch-finally方法来处理异常。
- 对于输入流来说，File类的对象对应的物理磁盘文件必须存在。否则会报`FileNotFoundException`错误。
- 对于输出流来说，File类的对象对应的物理磁盘文件可以不存在。
	- 如果文件不存在，则在输出过程中会自动创建文件，并写出数据。
	- 如果文件存在，使用`FileOutputStream(File file)`或`FileOutputStream(File file,false)`，输出数据过程中，会新建同名的文件并覆盖现有内容。使用`FileOutputStream(File file,true)`，则会在现有文件的末尾追加写出内容。
- 字节流和字符流的区别：字符流只能处理文本文件；字节流通常用来处理非文本文件，如果涉及到文本文件复制，也可以使用字节流处理。
	- 文本文件：.txt、.java、.c、.cpp、.py等。
	- 非文本文件：.doc、.xls、.jpg、.pdf、.mp3、.mp4等。

```java
package org.file;  
  
import java.io.*;  
  
public class FileTest5 {  
  
    public static void main(String[] args) {  
        test1();  
    }  
  
    /** 使用FileInputStream和FileOutputStream读写文件内容（完整版）  
     * 1. 创建文件对象, 当文件端点，传输给FileInputStream和FileOutputStream  
     * 2. 创建FileInputStream和FileOutputStream对象  
     * 3. 读写文件内容  
     * 4. 关闭FileInputStream和FileOutputStream对象  
     * 注意：文件包含文本文件和非文本文件，对于非文本文件，需要使用字节流进行读写  
     * */  
    public static void test1() {  
        FileInputStream fis = null;  
        FileOutputStream fos = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileInputStream和FileOutputStream  
            File srcFile = new File("image.jpg");  
            File destFile = new File("image_copy.jpg");  
            // 2. 创建FileInputStream和FileOutputStream对象  
            fis = new FileInputStream(srcFile);  
            fos = new FileOutputStream(destFile);  
            // 3. 读写文件内容  
            byte[] buffer = new byte[1024];  
            int len;  
            while ((len = fis.read(buffer)) != -1) {  
                fos.write(buffer, 0, len);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭FileInputStream和FileOutputStream对象  
            try {  
                if (fos != null) {  
                    fos.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (fis != null) {  
                    fis.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

### 5. 缓冲流

> 字节流：`BufferedInputStream`和`BufferedOutputStream`
> 字符流：`BufferedReader`和`BufferedWriter`

缓冲流是处理流的一种，是对节点流（文件流）进行处理，提升文件读写效率。

缓冲流包装对应关系：

| 类型  | 缓冲流（处理流）               | 节点流（文件流）           | 抽象基类           |
| --- | ---------------------- | ------------------ | -------------- |
| 字节流 | `BufferedInputStream`  | `FileInputStream`  | `InputStream`  |
| 字节流 | `BufferedOutputStream` | `FileOutputStream` | `OutputStream` |
| 字符流 | `BufferedReader`       | `FileReader`       | `Reader`       |
| 字符流 | `BufferedWriter`       | `FileWriter`       | `Writer`       |

**缓冲流的操作步骤**：

1. 创建读取或写出File类的对象。
2. 创建输入流或输出流（包括文件流、缓冲流），接收File类的对象。
3. 具体的读入或写出过程：
	- 读取：字节流：`int read(byte b[])`；字符流：`int read(char cbuf[], int off, int len)`和`String readLine()`。
	- 写出：字节流：`void write(byte b[], int off, int len)`；字符流：`void write(String str)`和`void flush()`。
4. 关闭流资源，避免内存泄露。

缓冲字节流的使用：

```java
package org.file;  
  
import java.io.*;  
  
public class FileTest6 {  
    public static void main(String[] args) {  
        test1();  
    }  
  
	/** 使用BufferedInputStream和BufferedOutputStream读写文件内容（完整版）
     * 1. 创建文件对象, 当文件端点，传输给FileInputStream和FileOutputStream  
     * 2. 创建FileInputStream和FileOutputStream对象，BufferedInputStream和BufferedOutputStream对象  
     * 3. 读写文件内容  
     * 4. 关闭FileInputStream和FileOutputStream对象，BufferedInputStream和BufferedOutputStream对象  
     * 注意：关闭时，先关闭BufferedInputStream和BufferedOutputStream对象，会对内层FileInputStream和FileOutputStream对象进行关闭  
     */  
    public static void test1() {  
        FileInputStream fis = null;  
        FileOutputStream fos = null;  
        BufferedInputStream bis = null;  
        BufferedOutputStream bos = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileInputStream和FileOutputStream  
            File srcFile = new File("image.jpg");  
            File destFile = new File("image_copy.jpg");  
            // 2. 创建FileInputStream和FileOutputStream对象，BufferedInputStream和BufferedOutputStream  
            fis = new FileInputStream(srcFile);  
            fos = new FileOutputStream(destFile);  
            bis = new BufferedInputStream(fis);  
            bos = new BufferedOutputStream(fos);  
  
            // 3. 读写文件内容  
            byte[] buffer = new byte[1024];  
            int len;  
            while ((len = bis.read(buffer)) != -1) {  
                bos.write(buffer, 0, len);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭FileInputStream和FileOutputStream对象，BufferedInputStream和BufferedOutputStream对象  
            try {  
                if (bos != null) {  
                    bos.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (bis != null) {  
                    bis.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (fos != null) {  
                    fos.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (fis != null) {  
                    fis.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

缓冲字节流和文件字节流的效率对比：

```java
package org.file;  
  
import java.io.*;  
  
public class FileTest6 {  
    public static void main(String[] args) {  
        long startTime = System.currentTimeMillis();  
        copyFileByBufferedStream("vedio.mp4", "vedio_copy.mp4");  
        long endTime = System.currentTimeMillis();  
        System.out.println("复制文件耗时：" + (endTime - startTime) + "ms");  
  
        // 分开依此执行  
        long startTime = System.currentTimeMillis();  
        copyFileByFileStream("vedio.mp4", "vedio_copy1.mp4");  
        long endTime = System.currentTimeMillis();  
        System.out.println("复制文件耗时：" + (endTime - startTime) + "ms");  
    }  

    /**  
     * 复制文件，使用BufferedInputStream和BufferedOutputStream读写文件内容  
     */  
    public static void copyFileByBufferedStream(String srcFilePath, String destFilePath) {  
        FileInputStream fis = null;  
        FileOutputStream fos = null;  
        BufferedInputStream bis = null;  
        BufferedOutputStream bos = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileInputStream和FileOutputStream  
            File srcFile = new File(srcFilePath);  
            File destFile = new File(destFilePath);  
            // 2. 创建FileInputStream和FileOutputStream对象，BufferedInputStream和BufferedOutputStream  
            fis = new FileInputStream(srcFile);  
            fos = new FileOutputStream(destFile);  
            bis = new BufferedInputStream(fis);  
            bos = new BufferedOutputStream(fos);  
  
            // 3. 读写文件内容  
            byte[] buffer = new byte[1024];  
            int len;  
            while ((len = bis.read(buffer)) != -1) {  
                bos.write(buffer, 0, len);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭BufferedInputStream和BufferedOutputStream对象  
            try {  
                if (bos != null) {  
                    bos.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (bis != null) {  
                    bis.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
  
    /**  
     * 复制文件，使用FileInputStream和FileOutputStream读写文件内容  
     * */  
    public static void copyFileByFileStream(String srcFilePath, String destFilePath) {  
        FileInputStream fis = null;  
        FileOutputStream fos = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileInputStream和FileOutputStream  
            File srcFile = new File(srcFilePath);  
            File destFile = new File(destFilePath);  
            // 2. 创建FileInputStream和FileOutputStream对象  
            fis = new FileInputStream(srcFile);  
            fos = new FileOutputStream(destFile);  
            // 3. 读写文件内容  
            byte[] buffer = new byte[1024];  
            int len;  
            while ((len = fis.read(buffer)) != -1) {  
                fos.write(buffer, 0, len);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭FileInputStream和FileOutputStream对象  
            try {  
                if (fos != null) {  
                    fos.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (fis != null) {  
                    fis.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

缓冲字符流的使用：

```java
package org.file;  
  
import java.io.*;  
  
public class FileTest6 {  
    public static void main(String[] args) {  
	    test2(); 
        test3();  
    }  
  
    /**  
     * 使用BufferedReader读文件内容（完整版）  
     * BufferedReader读取方式：  
     * 1. 使用char[] buffer = new char[1024]一次性读取buffer的大小  
     * 2. 使用readLine()一次读取一行  
     */  
    public static void test2() {  
        BufferedReader br = null;  
        try {  
            File file = new File("info.properties");  
            FileReader fis = new FileReader(file);  
            br = new BufferedReader(fis);  
  
            // 方式1: 一次读取buffer的大小  
            // char[] buffer = new char[1024];  
            // int len;            // while ((len = br.read(buffer)) != -1) {            //     String str = new String(buffer, 0, len);            //     System.out.println(str);            // }  
            // 方式2: 一次读取一行  
            String line;  
            while ((line = br.readLine()) != null) {  
                System.out.print(line + "\n");  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                if (br != null) {  
                    br.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
  
    /**  
     * 使用BufferedReader和BufferedWriter读写文件内容 （完整版）  
     * 1. 创建文件对象，当文件端点，传输给FileReader和FileWriter  
     * 2. 创建FileReader和FileWriter对象，BufferedReader和BufferedWriter对象  
     * 3. 读写文件内容  
     * 4. 关闭BufferedReader和BufferedWriter对象，FileReader和FileWriter对象  
     */  
    public static void test3() {  
        BufferedReader br = null;  
        BufferedWriter bw = null;  
        try {  
            // 1. 创建文件对象，当文件端点，传输给FileReader和FileWriter  
            File srcFile = new File("info.properties");  
            File destFile = new File("info_copy.properties");  
            // 2. 创建FileReader和FileWriter对象，BufferedReader和BufferedWriter对象  
            FileReader fr = new FileReader(srcFile);  
            FileWriter fw = new FileWriter(destFile);  
            br = new BufferedReader(fr);  
            bw = new BufferedWriter(fw);  
  
            // 3. 读写文件内容  
            String line;  
            while ((line = br.readLine()) != null) {  
                bw.write(line);  
                bw.newLine();  
                // bw.flush(); // 刷新缓冲区，将缓冲区中的数据立即写入文件  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭BufferedReader和BufferedWriter对象，FileReader和FileWriter对象  
            try {  
                if (bw != null) {  
                    bw.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (br != null) {  
                    br.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

### 6. 转换流

> 字符流：`InputStreamReader` 和 `OutputStreamWriter`

字符编码：字符、字符串、字符数组 -> 字节、字节数组。
字符解码：字节、字节数组 -> 字符、字符串、字符数组。

解码和编码之间的关系：在解码时需要使用与编码相同的字符集。或解码集必须要兼容编码集。 

转换流是一种处理流，实现字节与字符之间的转换。

- `InputStreamReader`：将输入型的字节流转换为输入型的字符流。
- `OutputStreamWriter`：将输出型的字符流转化为输出型的字节流。

使用`InputStreamReader`读取GBK/UTF-8文件：

```java
package org.file;  
  
import java.io.File;  
import java.io.FileInputStream;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.nio.charset.Charset;  
  
public class FileTest7 {  
    public static void main(String[] args) {  
        test1();  
    }  
  
    /** 使用InputStreamReader方式读取GBK/UTF-8文件  
     * 1. 创建File对象，当作参数传入FileInputStream构造器  
     * 2. 创建FileInputStream对象，InputStreamReader对象  
     * 3. 读取文件内容  
     * 4. 关闭InputStreamReader对象，自动释放FileInputStream对象  
     */  
    public static void test1() {  
        InputStreamReader isr = null;  
        try {  
            // 1. 创建File对象，当作参数传入FileInputStream构造器  
            File file = new File("D:\\FileTest\\file_gbk.txt");  
            // 2. 创建FileInputStream对象，InputStreamReader对象  
            FileInputStream fis = new FileInputStream(file);  
            // 在IDEA中默认的字符集为UTF-8  
            isr = new InputStreamReader(fis, Charset.forName("gbk"));  
  
            // 3. 读取文件内容  
            char[] buffer = new char[1024];  
            int len;  
            while ((len = isr.read(buffer)) != -1) {  
                String str = new String(buffer, 0, len);  
                System.out.println(str);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭InputStreamReader对象，自动释放FileInputStream对象  
            try {  
                if (isr != null) {  
                    isr.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

将GBK的文件转化为UTF-8的文件：

```java
package org.file;  
  
import java.io.*;  
import java.nio.charset.Charset;  
  
public class FileTest7 {  
    public static void main(String[] args) {  
        test2();  
    }  
  
    /** 将GBK的文件转化为UTF-8的文件  
     * 1. 创建源文件和目标文件  
     * 2. 节点流包裹文件，传入处理转换流  
     * 3. 读入内容并写出文件，转换编码格式  
     * 4. 关闭流资源  
     */  
    public static void test2() {  
        InputStreamReader isr = null;  
        OutputStreamWriter osw = null;  
        try {  
            // 1. 创建源文件和目标文件  
            File srcFile = new File("D:\\FileTest\\file_gbk.txt");  
            File destFile = new File("D:\\FileTest\\file_utf8.txt");  
            // 2. 节点流包裹文件，传入处理转换流  
            FileInputStream fis = new FileInputStream(srcFile);  
            isr = new InputStreamReader(fis, Charset.forName("gbk"));  
            FileOutputStream fos = new FileOutputStream(destFile);  
            osw = new OutputStreamWriter(fos, Charset.forName("utf8"));  
            // 3. 读入内容并写出文件，转换编码格式  
            char[] buffer = new char[1024];  
            int len;  
            while ((len = isr.read(buffer)) != -1) {  
                osw.write(buffer, 0, len);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            // 4. 关闭流资源  
            try {  
                if (osw != null) {  
                    osw.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
            try {  
                if (isr != null) {  
                    isr.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

文件字符集：

- ASCII：主要用来存储abc等英文和123数字、常用的标点符号。
- ISO-8859-1：拉丁码表，显示欧洲语言，单字节编码。
- GBK：最常用的中文码表，在GB2312标准基础上的扩展规范，使用双字节编码方案。向下兼容ASCII码。
- UTF-8：可以用来存储主要语言的所有字符。使用1~4个不等的字节表示一个字符。中文字符使用3个字节，向下兼容ASCII码。

在内存中的字符：

- 一个字符（char）占用2个字符，在内容中使用的字符集称为Unicode字符集。

UTF-8中的1~4字节表示：

| 字节数 | 二进制表示                                    |
| --- | ---------------------------------------- |
| 一字节 | `0xxxxxx`                                |
| 二字节 | `110xxxxx 10xxxxxx`                      |
| 三字节 | `1110xxxx 10xxxxxx 10xxxxxx`             |
| 四字节 | `11110xxx  10xxxxxx  10xxxxxx  10xxxxxx` |

### 7. 数据流

> 字节流：`DataInputStream` 和 `DataOutputStream`

数据流是一种处理流，可以将内容内存中定义的变量（基本的数据类型、部分引用数据类型）保存到文件中。

- `DataInputStream`：应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String类型的变量。
- `DataOutputStream`：应用程序将基本的数据类型，String类型的变量写入到输出流中。

数据流读取和写出方法：

| 方法                                               | 含义            |
| ------------------------------------------------ | ------------- |
| `byte readByte()/void writeByte(int v)`          | 读取和写出`byte`   |
| `short readShort()/void writeShort(int v)`       | 读取和写出`short`  |
| `char readChar()/void writeChars(String s)`      | 读取和写出`char`   |
| `int readInt()/void writeInt(int v)`             | 读取和写出`int`    |
| `long readLong()/void writeLong(long v)`         | 读取和写出`long`   |
| `double readDouble()/void writeDouble(double v)` | 读取和写出`double` |
| `String readUTF()/void writeUTF(String str)`     | 读取和写出`String` |

注意：数据流无法读取和写出对象数据。

### 8. 对象流

> 字节流：`ObjectInputStream` 和 `ObjectOutputStream`

对象流是一种处理流，可以读写基本数据和引用类型的变量。

对象的序列化/反序列化机制：

- 序列化过程：使用`ObjectOutputStream`流把内存中的Java对象转换成平台无关的二进制流，允许把这种二进制流持久保存在硬盘上或通过网络传输到另一个网络节点上。
- 反序列化过程：使用`ObjectInputStream`流将其他获得这种二进制流后，可以恢复成原来的Java对象。

使用`ObjectInputStream` 和 `ObjectOutputStream`读取和写出文件：

```java
package org.file;  
  
import java.io.*;  
  
public class FileTest8 {  
  
    public static void main(String[] args) {  
        test1();  
        test2();  
    }  
  
    /**  
     * 使用ObjectOutputStream将对象写入文件  
     * 1. 创建文件对象  
     * 2. 创建对象输出流对象和处理流对象  
     * 3. 使用对象对象流将对象写入文件  
     * 4. 关闭数据流  
     */  
    public static void test1() {  
        ObjectOutputStream oos = null;  
        try {  
            // 1. 创建文件对象  
            File file = new File("ObjectOutputStream.txt");  
            // 2. 创建对象输出流对象和处理流对象  
            FileOutputStream fos = new FileOutputStream(file);  
            oos = new ObjectOutputStream(fos);  
            // 3. 写数据并刷新  
            oos.writeUTF("中国HelloWorld");  
            oos.writeObject("对象内容");  
            oos.flush();  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                // 4. 关闭数据流  
                if (oos != null) {  
                    oos.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
  
    /**  
     * 使用ObjectInputStream从文件中读取对象  
     * 1. 创建文件对象  
     * 2. 创建对象输入流对象和处理流对象  
     * 3. 使用对象输入流从文件中读取对象  
     * 4. 关闭数据流  
     */  
    public static void test2() {  
        ObjectInputStream ois = null;  
        try {  
            // 1. 创建文件对象  
            File file = new File("ObjectOutputStream.txt");  
            // 2. 创建对象输出流对象和处理流对象  
            FileInputStream fis = new FileInputStream(file);  
            ois = new ObjectInputStream(fis);  
            // 3. 读取数据  
            String str = ois.readUTF();  
            System.out.println(str);  
            Object obj = ois.readObject();  
            System.out.println(obj);  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } catch (ClassNotFoundException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                // 4. 关闭数据流  
                if (ois != null) {  
                    ois.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

自定义类实现序列化机制需要满足以下三个条件：

1. 自定义类需要实现 `Serializable` 接口。
2. 自定义类声明一个全局常量：`static final long serialVersionUID = 42L;`，主要是用来唯一的标识当前类，避免在修改类后无法反序列化之前的已经序列化的对象。
3. 自定义类的各个属性也必须是可序列化的。基本类型默认是可以序列化的，引用类型是需要实现 `Serializable` 接口。

自定义类实现序列化机制的注意点：

1. 对象的某个属性是引用类型，那么该属性也需要进行序列化。
2. 类的所有属性必须是可序列化的，如果某个属性不需要序列化，则需要注明是瞬态的，使用`transient`关键词修饰。
3. 静态`static`变量的值是不会序列化的，因为静态的值不属于某个对象。

```java
package org.file;  
  
import java.io.Serializable;  
  
public class Person implements Serializable {  
    static final long serialVersionUID = 10001L;  
  
    String name;  
    int age;  
    // 修改类  
//    String address;  
  
    public Person() {  
  
    }  
  
    public Person(String name, int age) {  
        this.name = name;  
        this.age = age;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
  
    // 修改类：增加address的set和get方法  
//    public String getAddress() {  
//        return address;  
//    }  
//  
//    public void setAddress(String address) {  
//        this.address = address;  
//    }  
  
    @Override  
    public String toString() {  
    return "Person{" +  
                "name='" + name + '\'' +  
                ", age=" + age +  
                '}';  
    }  
  
  
//    @Override  
//    public String toString() {  
//        return "Person{" +  
//                "name='" + name + '\'' +  
//                ", age=" + age +  
//                ", address='" + address + '\'' +  
//                '}';  
//    }  
}

// 测试方法
package org.file;  
  
import java.io.*;  
  
public class FileTest8 {  
  
    public static void main(String[] args) {   
        test3();  
        test4();  
    }  

    /** 使用ObjectOutputStream向文件中写入对象  
     * 1. 创建文件对象  
     * 2. 创建对象输出流对象和处理流对象  
     * 3. 使用对象输出流向文件中写入对象  
     * 4. 关闭数据流  
     */  
    public static void test3() {  
        ObjectOutputStream oos = null;  
        try {  
            // 1. 创建文件对象  
            File file = new File("ObjectOutputStream.txt");  
            // 2. 创建对象输出流对象和处理流对象  
            FileOutputStream fos = new FileOutputStream(file);  
            oos = new ObjectOutputStream(fos);  
            // 3. 写数据并刷新  
            Person person=new Person("张三", 18);  
            oos.writeObject(person);  
            oos.flush();  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                // 4. 关闭数据流  
                if (oos != null) {  
                    oos.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
  
    /** 使用ObjectInputStream从文件中读取对象  
     * 1. 创建文件对象  
     * 2. 创建对象输出流对象和处理流对象  
     * 3. 使用对象输入流从文件中读取对象  
     * 4. 关闭数据流  
     */  
    public static void test4() {  
        ObjectInputStream ois = null;  
        try {  
            // 1. 创建文件对象  
            File file = new File("ObjectOutputStream.txt");  
            // 2. 创建对象输出流对象和处理流对象  
            FileInputStream fis = new FileInputStream(file);  
            ois = new ObjectInputStream(fis);  
            // 3. 读取数据  
            Object obj = ois.readObject();  
            System.out.println(obj);  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        } catch (ClassNotFoundException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                // 4. 关闭数据流  
                if (ois != null) {  
                    ois.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```

### 9. 其他流

**标准输入输出流**：

- `System.in`：标准输入流，默认从键盘输入。
- `System.out`：标准的输出流，默认从控制台输出。

通过如下方法，更改输入流和输出流的位置：

| 方法                             | 含义       |
| ------------------------------ | -------- |
| `void setIn(InputStream in)`   | 修改输入流的位置 |
| `void setOut(PrintStream out)` | 修改输出流的位置 |

从键盘上输入字符串，将输入的内容转化成大写输出，如果输入的是e或exit退出

```java
package org.file;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
  
public class FileTest9 {  
    public static void main(String[] args) {  
        test1();  
    }  
  
    /**  
     * 从键盘上输入字符串，将输入的内容转化成大写输出，如果输入的是e或exit退出  
     */  
    public static void test1() {  
        System.out.println("请输入信息（退出请输入e或exit）：");  
        // 把标准输入流的信息，包装成字符流，再包装为缓冲流  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String s = null;  
        try {  
            while (true) {  
                try {  
                    if (!((s = br.readLine()) != null)) break;  
                } catch (IOException e) {  
                    throw new RuntimeException(e);  
                }  
                if ("e".equalsIgnoreCase(s) || "exit".equalsIgnoreCase(s)) {  
                    System.out.println("退出程序");  
                    break;  
                } else {  
                    System.out.println("输入的信息是：" + s.toUpperCase());  
                    System.out.println("继续输入信息");  
                }  
            }  
        } catch (RuntimeException e) {  
            throw new RuntimeException(e);  
        } finally {  
            try {  
                if (br == null) {  
                    br.close();  
                }  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
  
        }  
    }  
}
```

实现System.in的效果

```java
package org.file;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
  
// 实现System.in的效果  
public class MyInput {  
  
    public static String readString() {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String str = null;  
        try {  
            str = br.readLine();  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
        return str;  
    }  
  
    public static int readInt() {  
        return Integer.parseInt(readString());  
    }  
  
    public static double readDouble() {  
        return Double.parseDouble(readString());  
    }  
  
    public static long readLong() {  
        return Long.parseLong(readString());  
    }  
  
    public static char[] readChar() {  
        return readString().toCharArray();  
    }  
  
    public static boolean readBoolean() {  
        return Boolean.parseBoolean(readString());  
    }  
  
    public static byte[] readByte() {  
        return readString().getBytes();  
    }  
  
    public static short readShort() {  
        return Short.parseShort(readString());  
    }  
}
```

**打印流**：

- `PrintStream`：以字节的形式输出。
- `PrintWriter`：以字符的形式输出。

`PrintStream`和`PrintWriter`注意事项：

1. `PrintStream`和`PrintWriter`的输出不会抛出IOException异常。
2. `PrintStream`和`PrintWriter`有自动flush功能。
3. `System.out`返回的是`PrintStream`的实例

使用PrintStream向文件中写入数据

```java
package org.file;  
  
import java.io.FileNotFoundException;  
import java.io.PrintStream;  
  
public class FileTest10 {  
    public static void main(String[] args) {  
        test1();  
    }  
  
    // 使用PrintStream向文件中写入数据  
    public static void test1() {  
        PrintStream ps = null;  
        try {  
            ps = new PrintStream("test.txt");  
            ps.println("hello world");  
            ps.println(1);  
            ps.println(1.0);  
            // 重新定义System.out输出位置  
            System.setOut(ps);  
            System.out.println("hello world");  
            System.out.println("你好");  
        } catch (FileNotFoundException e) {  
            throw new RuntimeException(e);  
        } finally {  
            if (ps != null) {  
                ps.close();  
            }  
        }  
    }  
}
```

自定义输出日志

```java
package org.file;  
  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.PrintStream;  
import java.text.SimpleDateFormat;  
import java.util.Date;  
  
public class Logger {  
    public static void log(String msg) {  
        try {  
            PrintStream out = new PrintStream(new FileOutputStream("test.log", true));  
            System.setOut(out);  
            Date nowTime = new Date();  
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
            System.out.println(sdf.format(nowTime) + "： " + msg);  
        } catch (FileNotFoundException e) {  
            throw new RuntimeException(e);  
        }  
    }  
}

// 测试一下
package org.file;  
  
import java.io.FileNotFoundException;  
import java.io.PrintStream;  
  
public class FileTest10 {  
    public static void main(String[] args) {  
        test2();  
    }  
  
    public static void test2() {  
        Logger.log("测试一下方法test2()");  
        Logger.log("测试完毕");  
    }  
}
```

**Scanner类的使用**：

```java
package org.file;  
  
import java.io.FileInputStream;  
import java.io.FileNotFoundException;  
import java.io.PrintStream;  
import java.util.Scanner;  
  
public class FileTest10 {  
    public static void main(String[] args) {  
        test3();  
        test4();  
    }  
	
	// 使用Scanner从文件中读取数据,并输出到指定的文件中
    public static void test3() {  
        Scanner input = null;  
        PrintStream ps = null;  
        try {  
            input = new Scanner(System.in);  
            ps = new PrintStream("test.txt");  
            while (true) {  
                System.out.println("请输入内容：");  
                String str = input.nextLine();  
                if ("e".equalsIgnoreCase(str) || "exit".equalsIgnoreCase(str)) {  
                    break;  
                }  
                ps.println(str);  
            }  
        } catch (FileNotFoundException e) {  
            throw new RuntimeException(e);  
        } finally {  
            if (ps != null) {  
                ps.close();  
            }  
            if (input != null) {  
                input.close();  
            }  
        }  
    }  

	// 使用Scanner从文件中读取数据,并输出到控制台中  
	public static void test4() {  
	    Scanner input = null;  
	    try {  
	        input = new Scanner(new FileInputStream("test.txt"));  
	        while (input.hasNext()) {  
	            String str = input.nextLine();  
	            System.out.println(str);  
	        }  
	    } catch (FileNotFoundException e) {  
	        throw new RuntimeException(e);  
	    } finally {  
	        if (input != null) {  
	            input.close();  
	        }  
	    }  
	}
}
```

三方框架：Apache Commons IO，快速使用文件的工具类。

```java
package org.file;  
  
import org.apache.commons.io.FileUtils;  
  
import java.io.*;  
import java.util.Scanner;  
  
public class FileTest10 {  
    public static void main(String[] args) {  
        test5();  
    }  

    public static void test5() {  
        try {  
            File srcFile = new File("test.txt");  
            File destFile = new File("test1.txt");  
            FileUtils.copyFile(srcFile, destFile);  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
}
```
